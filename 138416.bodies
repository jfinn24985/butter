class location_set
!!!183472.cpp!!!	begin() : location_set::location_set_iterator
return (root_ ? location_set_iterator(root_.get(), true) : location_set_iterator());
!!!183600.cpp!!!	end() : location_set::location_set_iterator
return location_set_iterator();
!!!183856.cpp!!!	find(in path : unistr) : location_set::location_set_iterator
QString real_{ (offset_path_ / path).path() };
for(auto it_ = begin(); it_ != end(); ++it_)
{
  if(it_->full_path() == real_)
  {
    return it_;
  }
}
return location_set_iterator();
!!!183344.cpp!!!	topdown() : location [*]
QVector< location * > v;
if(this->root_)
{
  location * loc{ this->root_.get() };
  // build vector
  int idx{ 0 };
  v.push_back(loc);
  while( idx != v.size() )
  {
    if( ! v[idx]->children_.empty() )
    {
      for( location * a : v[idx]->children_ )
      {
        v.push_back(a);
      }
    }
    ++idx;
  }
}
return v;
!!!150192.cpp!!!	serialize(inout a_os : QTextOStream) : void
#ifndef DEBUG
#define DEBUG 1
#endif
BUTTER_ALWAYS(DEBUG, "Programming error: attempt to get debug info in release build");
if (DEBUG)
{
  if(! root_)
  {
    a_os << "EMPTY location set.\n";
    return;
  }
  QVector< const location * > stack_;
  stack_.push_back(root_.get());
  while(! stack_.isEmpty())
  {
    location const * top_ = stack_.front();
    stack_.pop_front();
    a_os << "<<BEGIN location [" << top_->full_path() << "]\n";
    for(location const * loc_ : top_->children())
    {
      a_os << "                |- [" << loc_->path() << "]\n";
      if(! loc_->children().isEmpty())
      {
        stack_.push_back(loc_);
      }
    }
    a_os << "<<  END location [" << top_->full_path() << "]\n";
  }
}

!!!150064.cpp!!!	insert(in a_path : unistr) : location_set::location_set_iterator
QTextOStream l(stdout);
if(! root_)
{
  l << "No root, adding path [" << a_path << "]\n";
  // Empty root so this is the current "root" location
  root_.reset(new location(a_path));
  l << "         root.path   [" << root_->path() << "]\n";
  l << "         offset_path [" << offset_path_.path() << "]\n";
  return location_set_iterator(root_.get(), false);
}
enumerate_path search_path_{ this->offset_path_ / a_path };
//BUTTER_REQUIRE(end() == find(a_path), "This location is already present in the set" );
//
// [Programming notes] There are three possible insertion options.
//
// A) a_path is not a subdirectory of the current root location:
// A new root location is created and the current root's path is
// altered before adding as a child.  A new location is added to
// the new root with this path. The offset_path is adjusted for
// the new root location.
//
// B) A subdirectory of any existing location.  With the existing
// location being the closest match (eg new path is a/b/c/d,
// existing location has fullpath a/b and no children with
// fullpath a/b/c).
//
// B0) Have no sub-locations
//
// B1) The existing location has a child that is a subdirectory
// of the new path (eg new path is a/b/c, existing location has
// fullpath a/b and children exist with fullpaths a/b/c/...). A new
// location is added with the new path and the child (or children)
// moved to the new location with altered paths.
//
// B2) The existing location has a child with only a partial
// match or no match to the new path (eg new path is a/b/c and
// no existing children have fullpaths a/b/c/...). Add a location
// as child with the new path.
//
enumerate_path top_path_{ this->offset_path_ / root_->path_ };
l << "Have root, adding path [" << search_path_.path() << "]\n";
l << "               to path [" << top_path_.path() << "]\n";
l << "           common path [" << top_path_.create_common(search_path_) << "]\n";
l << "         relative path [" << top_path_.create_relative(search_path_) << "]\n";
if(".." != top_path_.create_relative(search_path_))
{
  l << " - have common root path\n";
  // case B
  if(0 == root_->children().size())
  {
    // case B0) No current children
    std::unique_ptr< location > newloc_{ new location(top_path_.create_relative(search_path_), *root_) };
    root_->children_.push_back(newloc_.release());
    l << "No children, adding path [" << top_path_.create_relative(search_path_) << "]\n";
    l << "         new.path      [" << root_->children_.back()->path() << "]\n";
    l << "         new.full_path [" << root_->children_.back()->full_path() << "]\n";
    l << "         offset_path   [" << offset_path_.path() << "]\n";
    return location_set_iterator(root_->children_.back(), false);
  }
  // Search for closest match (case B2 (and B1))
  location * loc_ = root_.get();
  search_path_.setPath(top_path_.create_relative(search_path_));
  location * tmp_;
  do
  {
    tmp_ = loc_;
    for(location * ll_ : loc_->children_)
    {
      enumerate_path sub_(ll_->path());
      if(sub_.path() == sub_.create_common(search_path_))
      {
        // Partial match, descend into location
        loc_ = ll_;
        search_path_.setPath(sub_.create_relative(search_path_));
        break;
      }
    }
  }
  while(tmp_ == loc_); // Found closest match
  std::unique_ptr< location > newloc_{ new location(search_path_.path(), *loc_) };
  loc_->children_.push_back( newloc_.release() );
  // Move location pointer to new location
  loc_ = loc_->children_.last();

  // POSSIBLY MOVE CHILDREN (case B1)
  //
  // loc_ is now new location, check if any children of parent should be
  // moved to the new location.
  // (search_path_ should contain the remaining path)
  QVector< int > tomove_;
  for(int i_ = 0; i_ + 1 < loc_->parent_->children_.size(); ++i_)
  {
    enumerate_path sub_(loc_->parent_->children_[i_]->path());
    if(search_path_ == search_path_.create_common(sub_))
    {
      tomove_.push_back(i_);
    }
  }
  while(! tomove_.isEmpty())
  {
    // Need to transfer into new location
    loc_->children_.push_back(loc_->parent_->children_[tomove_.last()]);
    loc_->parent_->children_.remove(tomove_.last());
    tomove_.pop_back();
    loc_->children_.last()->path_ = search_path_.create_relative(loc_->children_.last()->path_);
  }
  return location_set_iterator(loc_, false);
}
else
{
  // case A
  // Find common base, update offset, create new root, put current root into new
  // location. If new path doesn't match new root, also add as child
  return location_set_iterator();
}
