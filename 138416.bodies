class location_set
!!!185776.cpp!!!	base_path() : unistr
return (root_  
  ? (src_dir_ / root_->path()).path()
  : src_dir_.path());
!!!238640.cpp!!!	find_closest(in a_path : enumerate_path) : location
if( ! root_ ) return nullptr;
butter::enumerate_path const parent_path_{ root_->path() };
BUTTER_REQUIRE(parent_path_.has_subpath( a_path ), "This location is not a parent of the given path");
butter::enumerate_path const diff_path_( parent_path_.create_relative( a_path ));
location * cursor_ = root_.get();
for( unsigned int i_ = 0; i_ < diff_path_.depth(); ++i_ )
{
  butter::location * tmp_ = NULL;
  for( location * kid : cursor_->children_ )
  {
    if( kid->path_ == diff_path_.leaf_at(i_) )
    {
      tmp_ = kid;
      break;
    }
  }
  if( NULL == tmp_ )
  {
    break; // At closest point
  }
  else
  {
    cursor_ = tmp_;
  }
}
return cursor_;
!!!183344.cpp!!!	topdown() : location [*]
QVector< location * > v;
if(this->root_)
{
  location * loc{ this->root_.get() };
  // build vector
  int idx{ 0 };
  v.push_back(loc);
  while( idx != v.size() )
  {
    if( ! v[idx]->children_.empty() )
    {
      for( location * a : v[idx]->children_ )
      {
        v.push_back(a);
      }
    }
    ++idx;
  }
}
return v;
!!!150192.cpp!!!	serialize(inout a_os : QTextOStream) : void
#ifndef DEBUG
#define DEBUG 1
#endif
BUTTER_ALWAYS(DEBUG, "Programming error: attempt to get debug info in release build");
if (DEBUG)
{
  if(! root_)
  {
    a_os << "EMPTY location set.\n";
    return;
  }
  QVector< const location * > stack_;
  stack_.push_back(root_.get());
  while(! stack_.isEmpty())
  {
    location const * top_ = stack_.front();
    stack_.pop_front();
    a_os << "<<BEGIN location [" << top_->full_path() << "]\n";
    for(location const * loc_ : top_->children())
    {
      a_os << "                |- [" << loc_->path() << "]\n";
      if(! loc_->children().isEmpty())
      {
        stack_.push_back(loc_);
      }
    }
    a_os << "<<  END location [" << top_->full_path() << "]\n";
  }
}

!!!150064.cpp!!!	insert(in a_path : unistr) : location
#ifndef DEBUG
#define DEBUG 0
#endif
#if DEBUG
QTextOStream l(stdout);
#endif
if(! root_)
{
  l << "No root, adding path [" << a_path << "]\n";
  // Empty root so this is the current "root" location
  root_.reset(new location(a_path));
  l << "         root.path   [" << root_->path() << "]\n";
  return root_.get();
}
location * cache_ = root_.get();
enumerate_path search_path_{ a_path };
enumerate_path cache_path_{ cache_->path() };
// in "if" below "else" clause would mean current cache_ value fits.
if(! cache_path_.equality( search_path_ ) )
{
  if ( ! cache_path_.has_subpath( search_path_ ) )
  {
    //if ( DEBUG )
    //{
    l << "## Package below base dir. Reparenting base (TODO: current impl introduces jump paths).\n";
    //}
    // Reparent
    enumerate_path newbase_{ cache_path_.create_common( search_path_ ) };
    std::unique_ptr< location > super_{ new location(src_dir_.create_relative(newbase_)) };
    newbase_ = newbase_.create_relative(cache_path_);
    l << "### move old root location at : "<< root_->path() << " as child of new root " << super_->path() <<  "\n";
    l << "### with subpath : "<< newbase_.path() << "\n";
    cache_ = super_.get();
    for( unsigned int i_ = 0; i_ < newbase_.depth() - 1; ++i_ )
    {
      std::unique_ptr< location > tmp_( new location(newbase_.leaf_at(i_), *cache_ ) );
      l << "### add location at : "<< newbase_.leaf_at(i_) << " as child of " << cache_->path() <<  "\n";
      for(location * tmp : cache_->children())
      {
        l << "#### child of : "<<  cache_->path() << " ->  " << tmp->path() <<  "\n";
      }
      cache_ = tmp_.release();
    }
    root_->path_ = newbase_.leaf_at(newbase_.depth() - 1);
    cache_->children_.push_back(root_.release());
    root_.reset(super_.release());
    cache_ = root_.get();
    // Result is closest parent. Build descendent
    cache_path_ = root_->full_path();
    //if ( DEBUG )
    //{
    l << "## Found common parent [" << root_->full_path() << "]\n";
    //}
    if ( ! cache_path_.equality( search_path_ ) )
    {
      //if ( DEBUG )
      //{
      l << "## Package was below new base.\n";
      //}
      enumerate_path const diff_path_( cache_path_.create_relative( search_path_ ) );
      for( unsigned int i_ = 0; i_ < diff_path_.depth(); ++i_ )
      {
        l << "### add location at : "<< diff_path_.leaf_at(i_) << " as child of " << cache_->path() <<  "\n";
        std::unique_ptr< location > tmp_( new location(diff_path_.leaf_at(i_), *cache_ ) );
        for(location * tmp : cache_->children())
        {
          l << "#### child of : "<<  cache_->path() << " ->  " << tmp->path() <<  "\n";
        }
        cache_ = tmp_.release();
      }
    }
  }
  else
  {
    //if ( DEBUG )
    //{
    l << "## Package somewhere below cache, finding it\n";
    l << "### main path: "<< cache_path_.path() << "\n";
    l << "### search path: "<< search_path_.path() << "\n";
    //}
    cache_ = find_closest( search_path_ );
    cache_path_ = cache_->full_path();
    l << "## found location\n";
    l << "### main path: "<< cache_path_.path() << "\n";
    l << "### search path: "<< search_path_.path() << "\n";
    if( ! cache_path_.equality( search_path_ ) )
    {
      enumerate_path const diff_path_( cache_path_.create_relative( search_path_ ) );
      l << "### main path: "<< cache_path_.path() << "\n";
      l << "### search path: "<< search_path_.path() << "\n";
      l << "### diff path: "<< diff_path_.path() << "\n";
      for( unsigned int i_ = 0; i_ < diff_path_.depth(); ++i_ )
      {
        l << "### add location at : "<< diff_path_.leaf_at(i_) << " as child of " << cache_->path() <<  "\n";
        std::unique_ptr< location > tmp_( new location(diff_path_.leaf_at(i_), *cache_ ) );
        for(location * tmp : cache_->children())
        {
          l << "#### child of : "<<  cache_->path() << " ->  " << tmp->path() <<  "\n";
        }
        cache_ = tmp_.release();
      }
    }
  }
}
return cache_;

// [Programming notes] There are several possible insertion options.
//
// A) a_path is not a subdirectory of the current root location:
// A new root location is created and the current root's path is
// altered before adding as a child.  A new location is added to
// the new root with this path. The offset_path is adjusted for
// the new root location.
//
// B) A subdirectory of any existing location.  With the existing
// location being the closest match (eg new path is a/b/c/d,
// existing location has fullpath a/b and no children with
// fullpath a/b/c).
//
// B0) Have no sub-locations
//
// B1) The existing location has a child that is a subdirectory
// of the new path (eg new path is a/b/c, existing location has
// fullpath a/b and children exist with fullpaths a/b/c/...). A new
// location is added with the new path and the child (or children)
// moved to the new location with altered paths.
//
// B2) The existing location has a child with only a partial
// match or no match to the new path (eg new path is a/b/c and
// no existing children have fullpaths a/b/c/...). Add a location
// as child with the new path.
//
