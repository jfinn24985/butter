class location_set
!!!183472.cpp!!!	begin() : location_set::location_set_iterator
return location_set_iterator(this->root_.get(), true);
!!!183600.cpp!!!	end() : location_set::location_set_iterator
return location_set_iterator();
!!!150064.cpp!!!	insert(in a_path : unistr) : location_set::location_set_iterator
QDir const search_path_{ this->offset_path_ + '/' + a_path };
BUTTER_REQUIRE(end() == find(a_path), "This location is already present in the set" );
//
// [Programming notes] There are three possible insertion options.
//
// A) a_path is not a subdirectory of the current root location:
// A new root location is created and the current root's path is
// altered before adding as a child.  A new location is added to
// the new root with this path. The offset_path is adjusted for
// the new root location.
//
// B) A subdirectory of any existing location.  With the existing
// location being the closest match (eg new path is a/b/c/d,
// existing location has fullpath a/b and no children with
// fullpath a/b/c).
//
// B1) The existing location has a child that is a subdirectory
// of the new path (eg new path is a/b/c, existing location has
// fullpath a/b and children exist with fullpaths a/b/c/...). A new
// location is added with the new path and the child (or children)
// moved to the new location with altered paths.
//
// B2) The existing location has a child with only a partial
// match or no match to the new path (eg new path is a/b/c and
// no existing children have fullpaths a/b/c/...). Add a location
// as child with the new path.
//
QDir top_path_{ QString{ this->offset_path_ + '/' + root_->path_ } };
if(search_path_.path().startsWith(top_path_.path()))
{
  // case B
  QString p_{ search_path_.path().mid(top_path_.path().size()) };
  //  ^ used size to also remove last separator
  location * loc_ = root_.get();
  QStringList parts_;
  if (QDir::separator() == '/')
  {
    parts_ = p_.split('/');
  }
  else
  {
    QChar regex[] = { '[', '/', QDir::separator(), ']', '0' };
    QRegExp re{ QString(regex) };
    parts_ = p_.split(re);
  }
  QString np_;
  for(QString s_ : parts_)
  {
    np_ = (np_.isEmpty() ? s_ : np_ + '/' + s_);
    for(location * ll_ : loc_->children_)
    {
      if(ll_->path() == np_)
      {
        // Need to descend into location
        loc_ = ll_;
        np_.clear();
        break;
      }
    }
  }
  // loc_ now closest location, check for children that should be
  // moved to children of the new location
  std::unique_ptr< location > newloc_{ new location(np_, *loc_) };
  loc_->children_.push_back( newloc_.release() );
  // (np should contain the remaining path)
  for(int i_ = 0; i_ + 1 < loc_->children_.size(); ++i_)
  {
    if(loc_->children_[i_]->path().startsWith(np_))
    {
      // Need to transfer into new location
      newloc_->children_.push_back(loc_->children_[i_]);
      loc_->children_.remove(i_);
      --i_;
      newloc_->children_.last()->path_ = newloc_->children_.last()->path_.mid(np_.size());
    }
  }
//butter::pathcmp const diff_path_( parent_path_.create_relative( a_path ) );
//butter::location * cursor_ = this;
//for( unsigned int i_ = 0; i_ < diff_path_.depth(); ++i_ )
//{
//  std::unique_ptr< location > tmp_( new location(diff_path_.leaf_at(i_), *cursor_ ) );
//  if( cursor_->children_.count() == cursor_->children_.size() )
//  {
//    cursor_->children_.resize( cursor_->children_.size() + 1 );
//  }
//  cursor_->children_.insert( cursor_->children_.count(), tmp_.release() );
//  cursor_ = cursor_->children_.at( cursor_->children_.count() - 1 );
//}
  return location_set_iterator(loc_->children_.back(), false);
}
else
{
  // case A
  return location_set_iterator();
}
!!!183856.cpp!!!	find(in path : unistr) : location_set::location_set_iterator
QString real_{ offset_path() + '/' + path };
for(auto it_{ begin() }; it_ != end(); ++it_)
{
  if(it_->full_path() == real_)
  {
    return it_;
  }
}
return location_set_iterator();
!!!183344.cpp!!!	topdown() : location [*]
QVector< location * > v;
location * loc{ this->root_.get() };
// build vector
int idx{ 0 };
v.push_back(loc);
while( idx != v.size() )
{
  if( ! v[idx]->children_.empty() )
  {
    for( location * a : v[idx]->children_ )
    {
      v.push_back(a);
    }
  }
  ++idx;
}
return v;
!!!150192.cpp!!!	serialize(inout a_os : QTextOStream) : void
#ifndef DEBUG
#define DEBUG 1
#endif
BUTTER_ALWAYS(DEBUG, "Programming error: attempt to get debug info in release build");
if (DEBUG)
{
  location const * top_ = nullptr;
  int i_ = 0;
  for(location * loc_ : topdown())
  {
    if (loc_->parent() == top_ && top_ != nullptr)
    {
      a_os << "<<END location [" << top_->full_path () << "]\n";
      i_ = 0;
    }
    a_os << "[" << i_ << "] = " << loc_->path() << "\n";
    ++i_;
    if (loc_->parent() == top_)
    {
      top_ = loc_;
      a_os << "<<BEGIN location [" << top_->full_path() << "]\n";
    }
    // if (loc_->packages_.count () > 0)
    // {
    //   a_os << "Packages:\n";
    //   for (unsigned int i_(0); i_ < packages_.count (); ++i_)
    //   {
    //     a_os << "[" << i_ << "] = " << packages_.at (i_)->name () << "\n";
    //   }
    // }
  }
}

