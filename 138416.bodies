class location_set
!!!185776.cpp!!!	base_path() : unistr
return (root_  
  ? root_->path()
  : src_dir_.path());
!!!238640.cpp!!!	find_closest(in a_path : enumerate_path) : location
if( ! root_ ) return nullptr;
return find_closest_( src_dir_ / a_path );
!!!252464.cpp!!!	find_closest_(in a_path : enumerate_path) : location
BUTTER_ALWAYS( root_.get() != nullptr, "Should never call private find_closest_ with nul root" );
butter::enumerate_path const parent_path_{ root_->path() };
butter::enumerate_path const search_path_{ a_path }; // path already adjusted for src_dir
BUTTER_REQUIRE(parent_path_.has_subpath( search_path_ ), "This location is not a parent of the given path");
butter::enumerate_path const diff_path_( parent_path_.create_relative( search_path_ ));
location * cursor_ = root_.get();
for( unsigned int i_ = 0; i_ < diff_path_.depth(); ++i_ )
{
  butter::location * tmp_ = NULL;
  for( location * kid : cursor_->children_ )
  {
    if( kid->path_ == diff_path_.leaf_at(i_) )
    {
      tmp_ = kid;
      break;
    }
  }
  if( NULL == tmp_ )
  {
    break; // At closest point
  }
  else
  {
    cursor_ = tmp_;
  }
}
return cursor_;
!!!183344.cpp!!!	topdown() : location [*]
QVector< location * > v;
if(this->root_)
{
  location * loc{ this->root_.get() };
  // build vector
  int idx{ 0 };
  v.push_back(loc);
  while( idx != v.size() )
  {
    if( ! v[idx]->children_.empty() )
    {
      for( location * a : v[idx]->children_ )
      {
        v.push_back(a);
      }
    }
    ++idx;
  }
}
return v;
!!!150192.cpp!!!	serialize(inout a_os : QTextOStream) : void
#ifndef DEBUG
#define DEBUG 1
#endif
BUTTER_ALWAYS(DEBUG, "Programming error: attempt to get debug info in release build");
if (DEBUG)
{
  if(! root_)
  {
    a_os << "EMPTY location set.\n";
    return;
  }
  QVector< const location * > stack_;
  stack_.push_back(root_.get());
  while(! stack_.isEmpty())
  {
    location const * top_ = stack_.front();
    stack_.pop_front();
    a_os << "<<BEGIN location [" << top_->full_path() << "]\n";
    for(location const * loc_ : top_->children())
    {
      a_os << "                |- [" << loc_->path() << "]\n";
      if(! loc_->children().isEmpty())
      {
        stack_.push_back(loc_);
      }
    }
    a_os << "<<  END location [" << top_->full_path() << "]\n";
  }
}

!!!150064.cpp!!!	insert(in a_path : unistr) : location
#ifndef DEBUG
#define DEBUG 0
#endif
const bool debug_(false);
QTextOStream l(stdout);
if(debug_) {
  l << "###### Entering insert [" << a_path << "]\n";
}

const enumerate_path search_path_{ src_dir_ / a_path };
if(! root_)
{
  // Empty root so this is the current "root" location
  root_.reset(new location(search_path_.path()));
  if(debug_) {
    l << "# No root, adding path [" << search_path_.path() << "]\n";
  }
  return root_.get();
}
location * cache_ = root_.get();
if(debug_) {
  l << "# inserting path : " << search_path_.path() <<  ".\n";
}
enumerate_path cache_path_{ root_->path() };
// in "if" below "else" clause would mean current cache_ value fits.
if( ! cache_path_.equality(search_path_) )
{
  if ( ! cache_path_.has_subpath(search_path_) )
  {
    if(debug_) {
      l << "## Package below base dir. Reparenting base (TODO).\n";
    }
    // Reparent
    enumerate_path newbase_{ src_dir_ / src_dir_.create_relative( cache_path_.create_common( search_path_ )) };
    std::unique_ptr< location > super_{ new location(newbase_.path()) };
    // Move the old root element into the new root element
    cache_path_ = newbase_.create_relative(cache_path_);
    if(debug_) {
      l << "### move old root location at : "<< root_->path() << " to child of new root " << super_->path() <<  "\n";
      l << "### with new subpath : "<< cache_path_.path() << "\n";
    }
    cache_ = super_.get();
    for( unsigned int i_ = 0; i_ < cache_path_.depth() - 1; ++i_ )
    {
      std::unique_ptr< location > tmp_( new location(cache_path_.leaf_at(i_), *cache_ ) );
      if(debug_) {
        l << "### add location at : "<< cache_path_.leaf_at(i_) << " as child of " << cache_->path() <<  "\n";
      }
      cache_ = tmp_.release();
    }
    if(debug_) {
       l << "### moving old root : " << cache_path_.leaf_at(cache_path_.depth() - 1) << " as child of " << cache_->path() <<  "\n";
    }
    // change old roots path
    root_->path_ = cache_path_.leaf_at(cache_path_.depth() - 1);
    root_->parent_ = cache_;
    cache_->children_.push_back(root_.release());
    // Set the new root location
    root_.reset(super_.release());
    // New root is closest parent. Build descendent
    cache_ = root_.get();
    cache_path_ = root_->path();
    if ( debug_ ) {
      l << "## New common parent [" << cache_path_.path() << "]\n";
    }
    if ( ! cache_path_.equality( search_path_ ) )
    {
      enumerate_path const diff_path_( cache_path_.create_relative( search_path_ ) );
      if(debug_) {
        l << "## path is now : " << diff_path_.path() << ".\n";
      }
      for( unsigned int i_ = 0; i_ < diff_path_.depth(); ++i_ )
      {
        if(debug_) {
          l << "### add location at : "<< diff_path_.leaf_at(i_) << " as child of " << cache_->path() <<  "\n";
        }
        std::unique_ptr< location > tmp_( new location(diff_path_.leaf_at(i_), *cache_ ) );
        if(debug_) {
          for(location * tmp : cache_->children())
          {
            l << "#### child of : "<<  cache_->path() << " ->  " << tmp->path() <<  "\n";
          }
        }
        cache_ = tmp_.release();
      }
    }
  }
  else
  {
    if ( debug_ )
    {
      l << "## Package somewhere below root, finding it\n";
      l << "### main path: "<< cache_path_.path() << "\n";
      l << "### search path: "<< search_path_.path() << "\n";
    }
    cache_ = find_closest_( search_path_ );
    cache_path_ = cache_->full_path();
    if(debug_) {
      l << "## found location\n";
      l << "### main path: "<< cache_path_.path() << "\n";
      l << "### search path: "<< search_path_.path() << "\n";
    }
    if( ! cache_path_.equality( search_path_ ) )
    {
      enumerate_path const diff_path_( cache_path_.create_relative( search_path_ ) );
      if( debug_ ) {
        l << "### diff path: "<< diff_path_.path() << "\n";
      }
      for( unsigned int i_ = 0; i_ < diff_path_.depth(); ++i_ )
      {
        if( debug_ ) {
          l << "### add location at : "<< diff_path_.leaf_at(i_) << " as child of " << cache_->path() <<  "\n";
        }
        std::unique_ptr< location > tmp_( new location(diff_path_.leaf_at(i_), *cache_ ) );
        if( debug_ ) {
          for(location * tmp : cache_->children())
          {
            l << "#### child of : "<<  cache_->path() << " ->  " << tmp->path() <<  "\n";
          }
        }
        cache_ = tmp_.release();
      }
    }
  }
}
if(debug_) {
  l << "###### Exiting insert [" << a_path << "]\n";
}
return cache_;

// [Programming notes] There are several possible insertion options.
//
// A) a_path is not a subdirectory of the current root location:
// A new root location is created and the current root's path is
// altered before adding as a child.  A new location is added to
// the new root with this path. The offset_path is adjusted for
// the new root location.
//
// B) A subdirectory of any existing location.  With the existing
// location being the closest match (eg new path is a/b/c/d,
// existing location has fullpath a/b and no children with
// fullpath a/b/c).
//
// B0) Have no sub-locations
//
// B1) The existing location has a child that is a subdirectory
// of the new path (eg new path is a/b/c, existing location has
// fullpath a/b and children exist with fullpaths a/b/c/...). A new
// location is added with the new path and the child (or children)
// moved to the new location with altered paths.
//
// B2) The existing location has a child with only a partial
// match or no match to the new path (eg new path is a/b/c and
// no existing children have fullpaths a/b/c/...). Add a location
// as child with the new path.
//
