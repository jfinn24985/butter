class gmake_writer
!!!161065.cpp!!!	descendent_link(inout a_art : compound_artifact, in a_loc : location) : void
// Need to write the "makefiles.sys" include line.
QString tmp_;
QTextOStream desc_os_ (&tmp_);
desc_os_ << "include ";
const butter::location *location_cursor_ = &a_loc;
while (NULL != location_cursor_->parent ())
{
  desc_os_ << "../";
  location_cursor_ = location_cursor_->parent ();
}
desc_os_ << s_rules_name << "\n\n";

// Keep parent dir definitions.
if (NULL != a_loc.parent ())
{
  desc_os_ << "LOCALFLAGS:=$(USERFLAGS)\nLOCALLDFLAGS:=$(USERLDFLAGS)\n\n";

  // Add us to base makefile
  system_artifact_->close.second.append ("DIRS := $(DIRS) ");
  system_artifact_->close.second.append (a_loc.full_path ().mid (root_dir_.count ()));
  system_artifact_->close.second.append ("\n");
}
a_art.preamble.second.append (tmp_);

!!!160809.cpp!!!	initialise(inout a_base : location, in a_project : UmlItem) : void
// The include dir is the difference between the current fullpath and the
// top-projects hdrDir
QString init_text_;
QTextOStream init_os_ (&init_text_);
root_dir_ = a_base.full_path ();
BUTTER_CHECK (not root_dir_.isEmpty (), "<p><b>Program error:</b> Project root directory is not set properly.</p>");
init_os_ << "include " << s_rules_name << "\n\n";
init_os_ << "ROOTDIR := " << root_dir_ << "\n\n";
const QCString base_include_ (item_traits::hdrname (dynamic_cast< const UmlPackage& >(a_project)).path ());
if (root_dir_ != base_include_)
{
  init_os_ << "USERHDRS := $(USERHDRS) -I$(ROOTDIR)/" << base_include_.mid (root_dir_.count ()) << "\n\n";
}
QCString l_tmp;
if (requirements (a_project, l_tmp))
{
  init_os_ << l_tmp;
}
system_artifact_->preamble.second = init_text_;

// If no makefile docs...
if (a_base.find_uml_document (s_rules_name).isEmpty ())
{
  QCString l_ver;
  if (not const_cast< UmlItem & > (a_project).propertyValue (item_traits::butter_version_name, l_ver))
  {
    if (not const_cast< UmlItem & > (a_project).propertyValue (item_traits::version_name, l_ver))
    {
      l_ver = "1.0";
    }
  }
  QCString l_default_rules (s_default_rules);
  int l_i (0);
  const QCString l_project ("@@project@@");
  const QCString l_version ("@@version@@");
  if (-1 != (l_i = l_default_rules.find (l_project)))
  {
    l_default_rules.replace (l_i, l_project.length (), const_cast< UmlItem & > (a_project).name ());
  }
  if (-1 != (l_i = l_default_rules.find (l_version)))
  {
    l_default_rules.replace (l_i, l_version.length (), l_ver);
  };
  a_base.create_uml_document (s_rules_name)->set_Description (l_default_rules);
}
!!!175529.cpp!!!	install_target(in a_target_name : string, in a_loc_var : string, inout a_os : ostream, in a_install_type : uint = generic) : void
if (a_loc_var != item_traits::no_install_value)
{
  static const char * l_install_flag[] =
  {
    "BINIFLAGS"
  , "FILEIFLAGS"
  , "LIBIFLAGS"
  , "MANIFLAGS"
  };
  a_os << "install:: " << a_target_name << "\n";
  a_os << "\t$(INSTALL) -d $(" << a_loc_var << ")\n";
  a_os << "\t$(INSTALL) $(" << l_install_flag [a_install_type] << ") ";
  a_os << a_target_name << " $("  << a_loc_var << ")/" << a_target_name << "\n";
}
!!!160937.cpp!!!	local_target(in a_current : location, in a_target : UmlArtifact, inout a_localdoc : compound_artifact) : void
QCString l_here (item_traits::location (a_target));

const QCString target_name_ (const_cast< UmlArtifact& >(a_target).name ());
const QCString target_NAME_ (target_name_.upper ());
const QCString source_extension_ (CppSettings::sourceExtension ());

QVector < UmlArtifact > assoc_arts_ (const_cast< UmlArtifact& >(a_target).associatedArtifacts ());
if (not assoc_arts_.isEmpty ())
{
  bool Result (true);
  // a_target must be executable or library stereotype
  QCString target_suffix_; // The suffix for the target ("",".a","$(SUFEXE)","$(SUFIB)")
  QCString target_prefix_; // Prefix, "lib" or ""
  QCString target_other_type_;  // An "other" target type.
  QCString install_dir_;
  unsigned int install_type_ (generic);
  bool is_exe_;
  bool is_static_ (true);
  if (const_cast< UmlArtifact& >(a_target).stereotype () == item_traits::library_stereotype)
  {
    is_exe_ = false;
    QCString lib_stat_or_shar_;
    if (not const_cast< UmlArtifact& >(a_target).propertyValue (item_traits::butter_other_name, target_other_type_))
    {
      target_prefix_ = "lib";
      if (item_traits::property_search (a_target, item_traits::butter_lib_type_name, lib_stat_or_shar_) and item_traits::shared_value == lib_stat_or_shar_)
      {
        target_suffix_ = "$(SUFLIB)";
        is_static_ = false;
      }
      else
      {
        target_suffix_ = ".a";
      }
    }
    install_type_ = lib;
    if (not const_cast< UmlArtifact& >(a_target).propertyValue (item_traits::butter_install_name, install_dir_))
    {
      install_dir_ = item_traits::libdir_value;
    }
    else
    {
      if (install_dir_ != item_traits::libdir_value)
      {
        install_type_ = generic; // Reset to generic.
      }
    }
  }
  else if (const_cast< UmlArtifact& >(a_target).stereotype () == item_traits::executable_stereotype)
  {
    is_exe_ = true;
    target_suffix_ = "$(SUFEXE)";
    install_type_ = bin;
    if (not const_cast< UmlArtifact& >(a_target).propertyValue (item_traits::butter_install_name, install_dir_))
    {
      install_dir_ = item_traits::bindir_value;
    }
    else
    {
      if (install_dir_ != item_traits::bindir_value)
      {
        install_type_ = generic; // Reset to generic.
      }
    }
  }
  else
  {
    Result = false;
  }
  if (Result)
  {
    QString target_body_;
    QTextOStream target_os_ (&target_body_);
    QString lib_body_;
    QTextOStream lib_os_ (&lib_body_);
    QCString link_flags_;
    QCString includes_;
    QCString cflags_;
    bool first_ (true);
    target_os_ << target_NAME_ << "SRC := ";
    for (unsigned int l_i (0); l_i < assoc_arts_.size (); ++l_i)
    {
      UmlArtifact *tmp_ (assoc_arts_.at (l_i));
      if (tmp_->stereotype () == item_traits::library_stereotype)
      {
        QCString l_linker;
        if (tmp_->propertyValue (item_traits::butter_project_name, l_linker))
        {
          // Is an externally linked library, look for HDR and LINKLIB lines.
          find_hdr_link (tmp_->description (), includes_, link_flags_, cflags_);
        }
        else
        {
          UmlPackage * parent_package_ = dynamic_cast< UmlPackage * >(tmp_->parent ()->parent ());
          BUTTER_CHECK (NULL != parent_package_, "Grandparent of an artifact was not a package!");
          QCString l_str;
          if (item_traits::property_search (*tmp_, item_traits::butter_lib_type_name, l_str) and item_traits::shared_value == l_str)
          {
            lib_os_ << "-L$(ROOTDIR)/" << item_traits::dirname (*parent_package_).path ().mid (root_dir_.count ()) <<  " -l" << tmp_->name () << "$(SUFLIB) ";
          }
          else
          {
            lib_os_<< "$(ROOTDIR)/" << item_traits::dirname (*parent_package_).path ().mid (root_dir_.count ()) <<  "/lib" << tmp_->name () << ".a ";
          }
        }
      }
      else if (tmp_->stereotype () == item_traits::source_stereotype)
      {
        if (first_)
        {
          first_ = false;
        }
        else
        {
          target_os_ << " \\\n\t";
        }
        target_os_ << tmp_->name () << "." << source_extension_;
      }
    }
    target_os_ << "\n\n\n";

    target_os_ << "USERLDFLAGS := $(LOCALLDFLAGS)";
    if (not lib_body_.isEmpty () or not link_flags_.isEmpty ())
    {
      if (not lib_body_.isEmpty ())
      {
        target_os_ << " " << lib_body_;
      }
      if (not link_flags_.isEmpty ())
      {
        target_os_ << " " << link_flags_;
      }
    }
    target_os_ << "\n\nUSERFLAGS := $(LOCALFLAGS)";
    if (not includes_.isEmpty ())
    {
      target_os_ << " " << process_hdrs (includes_);
    }
    if (not cflags_.isEmpty ())
    {
      target_os_ << " " << cflags_;
    }
    target_os_ << "\n\n";

    target_os_ << "include $(" << target_NAME_ << "SRC:." << source_extension_ << "=.d)\n\n";
    target_os_ << target_prefix_ <<  target_name_ << target_suffix_ << " : $(" << target_NAME_ << "SRC:." << source_extension_ << "=.o) $(" << target_NAME_ << "SRC:." << source_extension_ << "=.d) " << lib_body_ << "\n";
    if (is_exe_)
    {
      target_os_ << "\t$(CCC) $(CXXFLAGS) -o " << target_prefix_ << target_name_ << target_suffix_ << " $(" << target_NAME_ << "SRC:." << source_extension_ << "=.o) $(LDFLAGS)\n\n\n";
    }
    else
    {
      if (not target_other_type_.isEmpty ())
      {
        QCString target_other_type_ (target_other_type_.upper ());
        int l_i (0); 
        while (-1 != (l_i = target_other_type_.find ('-'))) { target_other_type_[l_i] = '_'; }
        target_os_ << "\t$(" << target_other_type_ << ") " << target_name_ << " $(" << target_NAME_ << "SRC:." << source_extension_ << "=.o)\n\n\n";
      }
      else if (is_static_)
      {
        target_os_ << "\t$(AR) rus " << target_prefix_ << target_name_ << target_suffix_ << " $(" << target_NAME_ << "SRC:." << source_extension_ << "=.o)\n\n\n";
      }
      else
      {
        target_os_ << "\t$(CCC) $(CXXFLAGS) $(SHRLIBFLAGS) -o " << target_prefix_ << target_name_ << target_suffix_ << " $(" << target_NAME_ << "SRC:." << source_extension_ << "=.o) $(LDFLAGS)\n\n\n";
      }
    } 

    target_os_ << "all :: " << target_prefix_ << target_name_ << target_suffix_ << "\n\n";
    target_os_ << "USEROBJ := $(USEROBJ) $(" << target_NAME_ << "SRC:." << source_extension_ << "=.o)\n\n"; 
    target_os_ << "TARGETS := $(TARGETS) " << target_prefix_ << target_name_ << target_suffix_ << "\n\n";

//    if (not lib_stat_or_shar_.isEmpty ())
//    {
//      target_os_ << "<link>" << lib_stat_or_shar_ << "\n\t";
//    }
//    QCString tmp_;
//    if (requirements (a_target, tmp_))
//    {
//      target_os_ << tmp_;
//    }
//    target_os_ << ";\n\n";
    if (not install_dir_.isEmpty ())
    {
      install_target (target_prefix_ + target_name_ + target_suffix_, install_dir_, target_os_, install_type_);
    }
    a_localdoc.target (target_name_).second = target_body_;
  }
}
!!!162089.cpp!!!	process_hdrs(in a_inc_list : string) : string
QString Result;
QTextOStream l_os (&Result);
QStringList l_list (QStringList::split (" ", a_inc_list));
for (unsigned int l_i (0); l_i < l_list.count (); ++l_i)
{
  const QCString l_item ((*l_list.at (l_i)).stripWhiteSpace ());
  if ('$' != l_item[0] and QDir::isRelativePath (l_item))
  {
    l_os << "-I$(ROOTDIR)/" << l_item << " ";
  }
  else
  {
    l_os << "-I" << l_item << " ";
  }
}

return QCString (Result);
!!!161193.cpp!!!	requirements(in a_item : UmlItem, inout a_reqs : string) : bool
bool Result (false);
QCString l_tmp;
QString l_section;
QTextOStream l_os (&l_section);
if (const_cast< UmlItem& > (a_item).propertyValue (item_traits::butter_include_name, l_tmp))
{
  Result = true;
  l_os << "USERHDRS := $(USERHDRS) " << process_hdrs (l_tmp) << "\n";
}
if (item_traits::property_search (a_item, item_traits::butter_ldflags_name, l_tmp))
{
  Result = true;
  l_os << "USERLDFLAGS := $(USERLDFLAGS) " << l_tmp << "\n";
}
if (item_traits::property_search (a_item, item_traits::butter_flags_name, l_tmp))
{
  Result = true;
  l_os << "USERFLAGS := $(USERFLAGS) " << l_tmp << "\n";
}
if (Result)
{
  a_reqs = l_section;
}
return Result;
