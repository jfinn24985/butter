format 66
"Build" // Build
  revision 55
  modified_by 41 "finnerty"
  // class settings
  //class diagram settings
  draw_all_relations default hide_attributes default hide_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_infonote default shadow default show_stereotype_properties default
  //use case diagram settings
  package_name_in_tab default show_context default auto_label_position default draw_all_relations default class_drawing_mode default shadow default show_stereotype_properties default
  //sequence diagram settings
  show_full_operations_definition default write_horizontally default class_drawing_mode default drawing_language default draw_all_relations default shadow default show_stereotype_properties default
  //collaboration diagram settings
  show_full_operations_definition default show_hierarchical_rank default write_horizontally default drawing_language default package_name_in_tab default show_context default draw_all_relations default shadow default show_stereotype_properties default
  //object diagram settings
   write_horizontally default package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default show_stereotype_properties default
  //component diagram settings
  package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default
  draw_component_as_icon default show_component_req_prov default show_component_rea default show_stereotype_properties default
  //deployment diagram settings
  package_name_in_tab default show_context default write_horizontally default auto_label_position default draw_all_relations default shadow default
  draw_component_as_icon default show_component_req_prov default show_component_rea default show_stereotype_properties default
  //state diagram settings
  package_name_in_tab default show_context default auto_label_position default write_trans_label_horizontally default show_trans_definition default draw_all_relations default shadow default
  show_activities default region_horizontally default drawing_language default show_stereotype_properties default
  //activity diagram settings
  package_name_in_tab default show_context default show_opaque_action_definition default auto_label_position default write_flow_label_horizontally default draw_all_relations default shadow default
  show_infonote default drawing_language default show_stereotype_properties default
  
  cpp_src_dir ".."
  comment "Project for project documentation and build files."
  deploymentview 130345 "config"
    //deployment diagram settings
    package_name_in_tab default show_context default write_horizontally default auto_label_position default draw_all_relations default shadow default
    draw_component_as_icon default show_component_req_prov default show_component_rea default show_stereotype_properties default
    artifact 141737 "README.t2t"
      stereotype "document"
      associated_artifacts
      end
      comment "The butter plugout
Butter Project (version 1.2: Beta 2)
October 2009


=Introduction=

Butter is a bouml plug-out for generating a build system for (at the moment) C++ projects. It can 
produce build systems in three styles: Boost jam, standard jam and gnu make. The generated build 
systems should produce nearly equivalent results (see [limitations #limits]). Optionally you can 
use target types that are specific to a particular build system style.

== Motivation ==

You can define the build system information within //bouml// but it is difficult to write/convert 
this into anything.  The genpro tool allows one build-target at a time to be created.  The 
//butter// project takes all the build targets and creates a build system in one go.

== Quick Example ==

Create a //bouml// project as usual but with no external library.
+ Create project.
+ Add classes and associated artifacts.
+ Define project properties, such as generation directory, as normal.
+ Generate source code.


The minimal extra steps to create build system are.
+ Create executable artifact and associate source artifacts.
+ Set property ``butter style`` on project package to ``make``
+ Run //butter//.
+ Use ``make`` to build executable.


To use an external library, create an artifact and set some 
[properties #properties] (an example is given for the Qt3
library in the [in-depth tutorial #eg_external_library]).
All that remains is to associate this library with the 
project targets.

==Target Variants==

The build systems can have several global targets.  The default target is
a ``debug`` variant.  Optimised output uses the ``release`` variant.
An ``install`` variant is also available (included with the ``release``
variant //for boost jam//).  Additionally the ``clean`` target will remove
files created by the build process.

Example invocations are:
```
make # default = debug
make VARIANT=RELEASE
make install VARIANT=RELEASE
make clean
jam # default = debug
jam -sVARIANT=RELEASE
jam install
jam clean
bjam # default = debug
bjam release # includes installation
bjam clean
```

==Version and license information==

This is the second beta release of the //butter// project. It is fully functional and a very 
useful tool, however not every situation has been tested. This could lead to complete failures
of the tool (the plugout starts then \"disappears\") or any errors that are reported may not make 
sense.  Please let me know your experiences of using this tool and any suggestions or feedback.

The source code, documentation and associated bouml project files are released under the GNU 
Public License.

==Future directions==

In this release of //butter// there is a simple //install// target type. It 
is intended that future releases will improve this capability with particular 
emphasis on producing systems designed for easy integration with the //autoconf// system.

People are free to contribute additional build system styles and make comments to improve the
existing styles.

=Building butter=

The //butter// project contains the //butter// files and properties needed to create a 
build system for building //butter// itself.  However, to create your first butter version
you use the //genpro// tool on the ``butter.plugout`` artifact to create a ``qmake`` //pro//
file.

When built on unix systems in debug mode //butter// pauses with a dialog box at the start to allow
you to optionally attach a debugger.

=Adding butter to bouml=

The //butter// plugout always operates on the entire project so it does not care where 
it is started.  You can therefore set it to apply at any location you want. To use the 
//butter// tool, place the executable in the //bouml// directory containing 
the other tools.  Then in the //Tools//->//tools settings// dialog select the //Others//
tab and add something like the following:

|| Executable | display | Prj | 
| butter | Create build system | X | ...

=Important concepts, features and limitations=[limit]

** Limitations **
- **Directory Names**: All source directory names must be unique as they are used 
as a \"sub-project-name\" in the jam style. (eg ``src/A/C`` and ``src/B/C`` are not allowed)
- **Single-directory source**: The source and documents for a target must 
be in the same directory as the target.  Work-around: Group source
artifacts into a static library in each directory then associate targets with
these libraries.
- **Library type** Boost jam defaults to building shared libraries, while other styles
can only create static libraries (in this version).
- **Name clashes** Effort is made to avoid this problem but it may occur. The
message from boost jam is \"error: No best alternative for [somename]\". You may have to
rename an artifact to avoid this.
- **Compiler names** The variables used to define compilers and their flags is not 
consistent across build systems. This is an issue only with the ``butter compiler`` 
property when you want to be able to change between the build system styles.



** Concepts **
- **Base directory**: The directory or folder that is below all source folders. This is 
automatically detected or can be set with the ``butter base`` property.
 - ``standard jam`` needs a single parent folder. 
- **Style**: //butter// can produce build systems for ``boost jam``, ``standard jam``
and ``gnu make``. The build styles produce equivalent but not identical results. The default 
style is //boost jam//.
- **Target**: A build target is a UML artifact with the library or executable stereotype.
 - **External target**: A UML artifact with the library or executable stereotype and the
``butter project`` property refers to an external target. The artifact's //ldflags//, //include// 
and //flags// are then added to any normal target that is associated to it.


** Features **
- **build variant**: The //butter// plugout creates a build system that has four basic 
build-system variants (//default// and //release// build librarys/executables, //clean// 
and //install//) independent of build system style. 
 - ``boost jam`` performs installation with the //release// variant and has no //install//.
- **Documents**: //butter// writes the description of any document artifacts to the filesystem.  
 - **Mixed language programming**: [See below. #multi] create a document artifact with 
an appropriate name and put the source code into the description field. Associate the document 
with a target.
- **Multi-level target**: A target UML artifact need not be in the same directory as other 
target UML artifacts that use/reference it.
- **Target types**: The ``butter other`` property on a library artifact allows you to use other 
targets types (see documentation on [artifact properties #art_prop]).


=Including build information in bouml=

//Butter// has a goal of being easy to use in simple cases and flexible enough
to handle complex cases.  The basic operation is to put the definition of the 
project's executable and library artifacts into a build system.  In the case 
where a project has no external dependencies simply associating source, 
-executable and library artifacts may be all that need be done. Adding extra 
build information is done mainly using [properties #properties] on mainly 
the project package and individual artifacts.  

External libraries may have information that can
not be given to each style in the same way.  For example ``pkg-config`` and
similar programs that give compile settings dynamically need different treatment
for boost jam than make.  In these rare cases you have several options:
- put the build style into the artifact's [description field #desc_enc]
- create a separate document for each style that is included in a build file.
- directly into a [build file #buildfile] artifact


Documentation and non C++ source files are created with document artifacts 
in //bouml// and placing the text or source code into the description field. //Butter//
writes the description field of all document artifacts into a file with the artifact's
name.


==Properties==[properties]

The following table gives an overview of the available properties, the //bouml//
object that they can be applied to the reason for the property.  Note that
all //butter// properties are the word ``butter`` followed by a keyword.  The
``project`` in the table is the top project package; ``executable``, ``library``,
``source``, ``document`` refer to artifacts of the given stereotype.


|| Property name    | bouml object(s)     | Reason           |
| butter build-dir  | project             | Directory for object files, etc.
| butter base       | project             | Hint for the base directory of the build tree
| butter buildfile  | library             | (External library) Name of a file to use for settings
| butter compiler   | document            | Variable name as used in the build system for a compiler (eg. CC for C). Required when you need to set compile flags for a document (the source type currently must be deduced from the document name by the build system.)
|                        | executable, library  | Variable name as used in the build system for a compiler (eg. CC for C) to use to link the target.
| butter flags      | project             | Define project wide compile flags.
|                   | executable, library | Compile flags for associated sources
|                   | source              | Source specific flags
|                   | document            | Source specific flags (see compiler property)
| butter include    | project             | Define project wide include diretories.
|                   | executable, library | Include directories for associated sources
|                   | source              | Source specific includes
|                   | document            | Source specific includes (see compiler property)
| butter install    | executable, library | Specify one of the predefined install locations
| butter ldflags    | project             | Define project wide link flags.
|                   | executable, library | Link flags for associated sources
|                   | source, document    | Link flags to added to associated executables or libraries
| butter log-level  | project             | Trace output verboseness (0 = warn (defualt), 1 = information, 2 = debug)
| butter other      | library             | Change build target type
|                   | document            | 'nowrite' means ignore document
| butter project    | library             | Indicate library is an external target
| butter style      | project             | Which build style? boost, standard or make.
| butter type       | library             | Set library as shared or static
|                   | project, package    | Set default library type for contents of package
| butter version    | project             | Initial setting of VERSIONDIR in build system



===Project package specific properties===

: butter style = boost | standard | jam
This names the style of build system you want to use. The **default** value is
``boost``. The other alternatives are ``standard`` (for standard jam) and 
``make``. If the name of the style is not recognised you get an error message
and the **default** style is used.
: butter base = [dir]
Indicates the relationship of the //desired// project root directory and the root directory 
set in C++ settings. For example I set the C++ root directory to be ``[real-root]/include`` and
set //butter base// to ``..`` (I also set the src directories to \"``../src/[name]``\").
This will be ignored if the directory is not a parent of all the source directories.
: butter build-dir = [dir]
Indicate a directory where the build files will be created. This is currently only
used by the ``boost`` style.


===Artifact properties===[art_prop]

Those properties with an (*) may be inherited from parent objects up to
and including the project, with //local// definitions overriding more
distant definitions. Properties with an (@) when
used on the project package are added to every build target, the project
level properties are combined with that of the target.  Properties
with an (#) may also be set in the target's description 
[see Artifact Descriptions #desc_enc].

: butter include = dir1 dir2 (@)(#)
A list of header directories to search for included files.  The list is
the bare directory name, ``-I`` will be prepended for those systems
that require it.
: butter flags = ... (@)(#)
A list of compiler options for building the object files. This is
used as-is.
: butter ldflags = ... (@)(#)
A list of linker options for building the target. This is
used as-is.
: butter install = ...
**Library** and **executable** targets are by default installed into the
``BINDIR`` and ``LIBDIR`` install locations. To install in a different location
set this property to one of the other install directory names. If
you do not want the target installed set it to ``NONE``.
: butter type = static | shared (*)
Indicate whether a library target is to be build as a static code archive
or a dynamic library.

: butter project = [name]
For **library** stereotype artifacts only. This indicates that the artifact
represents an //external// library that will not be build but associated
with other targets.  In this target the //include//, //flag// and //link//
definitions are those for the //external// library and are automatically
added to //internal// targets that reference this //external// target.

For the ``boost`` style, ``[name]`` is used to group external projects which
have the same external project name.
: butter other = [name]
For **library** stereotype artifacts only. This indicates that the artifact
represents an alternate build target. These are build style specific:
 - boost | standard : Used as-is as the jam rule name.
 - make : ``$(NAME_IN_UPPERCASE)`` used as the target build tool.
The definition for what these do must be defined by the user or 
must be already present in the build systems.
: butter buildfile = [name]
For **library** stereotype artifacts with //butter other// property only.
This indicates an external file that contains definitions to use
for this //external// library.
 - boost : Adds ``using [name] ;``
 - standard : Adds ``include [name].jam ;``
 - make : Adds ``include [name].make``


: butter document : nowrite
For **document** stereotype artifacts only. This indicates that the document
should not be written to disk. By default //butter// will write all
documents to disk.



==Artifact Descriptions==[desc_enc]

The //butter// plugout can use the description from target artifacts 
to store generic or style-specific build information. It uses section
markers that look like the replacement markers used in bouml, namely
``${butter_generic}`` for the section containing generic information.
Each style has a section marker defined as ``${butter_`` + style name + ``}``.

+ no section marker = use entire description content
+ style specific marker = use marked section
+ generic marker = if no specific section and generic marker is
 present, use the generic section.
+ markers present but not generic or for this style = empty section.


Once a section has been discovered it is searched for lines containing
the following definition labels.
```
HDR=
FLAGS=
LINK=
```
which are converted to //include//, //flag// and //link// definitions. These
are used in exactly the same way as the corresponding properties above. If no
labels are present then the section is written as-is into the build file.


==Artifacts named Jamfile/Jamroot/makefile==[buildfile]

These artifacts will contain sections of text between start/end markers
that were generated by //butter//.  Any text outside these markers will
not be changed when //butter// is rerun and will be writen with the rest
of the file.  The markers look as below with '['label']' replaced be
the section label.

```
##START:[label]
...
##END:[label]
```

==Build style special artifacts==[specialfile]

Each styles uses an artifact containing global definitions at the 
top-level project directory.  Once created these artifacts are not changed
by //butter//. The names of these build files are:

|| style | filename
| ``make`` | //makefile.sys//
| ``standard`` | //Jamrules//
| ``boost`` | //local.jam//


**NOTE** The content of these files, particularly //makefile.sys//, is essential
for the correct operation of the generated build system.  Therefore, care
should be taken when editing these artifacts in bouml. If something does
go wrong simply renaming the artifact in bouml will cause a fresh
default version to be created.

**HINT** You can save these artifacts into your //bouml// template project.

=Advanced usage=[advanced]

==Installation feature==

All build targets are added to the default invocation of the build tool. In
addition an //install// target is supported.  Currently how the install target 
is invoked varies with each build style.  For the ``make`` style an //install//
target is added and must be called manually, for ``boost`` the installation 
occurs automatically for //release// variant builds.

One goal of the //butter// plugout is to facilitate project delivery as well
as building.  We assume that the project packaging is likely to be managed
by the GNU autoconf or similar tool.  To facilitate using such a tool each
style contains a set of variables for each installation target directory used 
by autoconf.  The names of these variables can be found by looking at one of 
the [special build files #specialfile]. For example the default variable used
for a **library** target is ``LIBDIR`` and for an **executable** target it
is ``BINDIR``.  The install location can be changed by setting the 
``butter install`` property of the target to the name of one of the other 
variables.

==Documentation/man pages==

Let us assume that you have the text for a man page written in txt2tags markup
in **document** artifact ``butter.t2t`` and also you have a ``man`` build rule 
for converting the document to a man page.  To convert the artifact to a man 
page and have it installed we create a **library** artifact ``butter.1`` and 
associate ``butter.t2t`` to it. We then set the following properties on the new
**library** artifact:
| butter other: | man
| butter install: | MAN1




==Multi-language programming==[multi]

//Butter// allows the easy inclusion of source files from other programming 
languages.

- Create a artifact with the //document// stereotype and the source filename,
eg \"c_interface.c\", \"c_interface.h\" or \"matrix_ops.F\".
- Write the source code directly into the document's description field.
- Include the document in a //library// or //executable// artifact as
if it was a normal source file.
- Optionally define //compiler//, //flags//, //include// and or //ldflags// 
properties on the document.
 - Note the //compiler// property is required whenever //flags// or //include// 
properties are defined.


==Boost jam limitations==[boost_limit]

The description field of external libraries can be used to give
detailed instructions for the build system ([see Artifact Description #desc_enc]).
This text can be searched for encoded flags or used as-is which may confuse
this style. This is resolved by using the generic section label which forces
the search for encoded flags.

For example if we want to use the boost filesystem library and use a
generic argument and we want to get the following in ``Jamroot``.
```
alias filesystem : : : : <linkflags>\"-lboost_filesystem\" ;
```
Using just the following results in the text
being placed as-is in ''Jamroot'' and therefore an error when we try to compile.
```
LINK=-lboost_filesystem
```
Instead using the generic section label forces the section to be treated as
containing encoded flags and gets us what we want.
```
${boost_generic}
LINK=-lboost_filesystem
```


==Jam standard limitations==

The ``standard`` ``jam`` program has the limitation that include 
directories and compilation flags are set globally for each compilation
directory.  This obviously means that the same set of 
compilation flags and include directories are seen by all targets
built from a single directory and is a serious limitation if you want 
two targets in the same directory to have conflicting flags.  Note this
limitation is not true for the linker flags which are always target 
specific. The plugout does attempt to merge the information from each 
target to remove duplicate information.

==Make limitations==[make_limit]

(1)  The current make style requires a make program (eg GNU make) that allows 
immediately assigned variables allowing constructs such as ``A:=$(A) -B -C``, 
which result in a cyclic dependency in standard make.

(2) The ``jam`` program manages dependencies for the entire project and correctly 
rebuilds all affected targets in the correct order.  The ``make`` style creates
makefiles were targets will be built in an arbitrary order.  This means that 
targets that depend on other targets (eg a source archive library) may not be 
updated correctly.  This means that you may need to run ``make`` several times 
before all targets are updated correctly even if no errors are reported.

For example, take the case of target //A// being dependent on target //B// 
in different directories and where //B// is build after //A//. The first ``make -k``
run will have an error for building //A// as it cannot find //B//. This is good 
as you can see that you must run ``make`` again.  So you call ``make -k`` again and
all is now updated correctly.  However, when you later make a change 
to //B// the next ``make`` run will rebuild //B// but not //A// as the old 
version of //B// will be seen when ``make`` checks target //A//.  Furthermore 
there will be no error message!  The only sure indication that all targets are 
updated is when a ``make`` run performs no actions.

=In-depth Tutorial=

==Build Project==

The following example uses the //butter// bouml project as an example. In this project
we have five sub-packages:
- //Build// contains definitions for top-level/system build files of the base project. It 
also includes this README file. Its source location is ``..``
- //API BASE// contains the fixed part of the bouml plug-out API. Its header location is 
modified to be ``bouml`` and src location as ``../src/bouml``.
- //API USER// contains the user editable part of the bouml plug-out API. Its header 
location is ``bouml`` and src location as ``../src/bouml``, the same as the //API BASE//
package.
- //butter// contains the non-bouml-API related classes of the project. Its header location is 
``butter`` and src location is ``../src/butter``.
- //External// contains the references to external classes and libraries.


**TIP** I set the generation settings root directory to be ``/blah/blah/include`` and 
then each package as header = ``name``, source = ``../src/name``.  When combined with the
``#include : with root relative path`` you can create projects with source separated from
header files and need only include one ``-I`` include path. This is particularly useful 
when you want to create a library that other people may use as you can easily package up the
header files and require library clients to use only one ``-I`` include path for your
library.

==Initial set-up==

The //butter// system assumes that the bouml source root directory, as specified in the generation 
settings dialogue, is the root of the build system.  You can also use a user defined 
**butter base** property on the project package to define a relative path between this 
bouml root directory and some other desired build base directory.  However, if necessary the 
system will automatically reset the base directory to a directory that is a parent of all the 
source directories in the project. If no package exists at the base location the system will ask
for confirmation before creating such a package. 

In the example the generation settings root directory is ``[my-project]/include`` with each 
package header as ``[package]`` and package source directory as ``../src/[package]``.  I 
therefore need to specify the build base directory as the parent of the root directory with 
a user property on the base package:

```
butter base  : ..
```

We also need to define which style of build system to use. This is done by defining a
``butter style`` user property on the base package. If this is not defined then the
boost jam style is the default (it is also used whenever the style name is not 
recognised).

```
butter style : make
```

When using the boost jam style we can also define where we want the object files and targets
to be built using the ``butter build-dir`` property:

```
butter build-dir : build
```

The standard bouml plug-out project uses a single directory for all the header and source files.
I have modified this to use different directories for headers and source and also placed the
headers in a sub-directory of the generation root.  I have also defined 
``#include : with root relative path`` generation option. For includes directives automatically 
generated by bouml I need not do anything more, however many includes are manually defined 
in the //API BASE// and //API USER// packages.  I therefore need to add ``include/bouml`` as 
an include directory for all targets.

In addition I will be using definitions and settings specific to the C++ system. I therefore
need to define the ``-DWITHCPP`` flag for all targets.  Lastly, I have a multi-directory 
project but only want a single application so I therefore want to build all libraries targets as
static. To do this I set the following user properties on the base package:

```
butter flags : -DWITHCPP
butter include : include/bouml
butter type : static
```

==External library target==[eg_external_library]

The bouml API uses the QT3 library and this is used as a basis library for the //butter// 
project. I therefore need to define the include and linker options for this library. These could
be added to the project level options above, but then they would apply to all targets. A more
flexible way is to define a library artifact to act as a placeholder for an external library in the
same way classes defined as external act as placeholders.  (Here I include these in a package
named //External// but the actual name is not significant to the system) Under the 
//External// package I define an artifact called //qt// which I set to have the library 
stereotype. I then mark it as an external library by defining the ``butter project`` user 
property:

```
butter project : qt3
```

I define the include and link options by setting the library description to:

```
${butter_generic}
HDR=${QTDIR}/include
LINK=-L${QTDIR}/lib -lqt-mt -lXext -lX11 -lm
```

The ``${butter_generic}`` is a section marker indicating the following description contains 
information that is used for all styles. The ``HDR=`` and ``LINK=`` obviously (also ``FLAGS=``)
define the include directories and link flags. Note that the include directories are specified
without ``-I``.

===Style specific options===

Using the ``${butter_generic}`` marker gives //butter// information to translate into
each style.  However it is possible to provide definitions on a per-style basis.  A simple 
example is wanting to use one of the compile option configuration programs 
supplied with many libraries, in this case the standard method will not work for boost jam
so an alternative for that must be used.

```
${butter_generic}
FLAGS=`pkg-config qt-mt --cflags`
LINK=`pkg-config qt-mt --libs`
${butter_boost}
# This may not work, but given as an example
.qtcompileflags = [ string.join [ string.words [ SHELL \"pkg-config qt-mt --cflags-only-other\" ] ] : \" \" ] ;
.qtincprefix = [ MATCH \"-I\\(.*\\)\" : [ string.words [ SHELL \"pkg-config qt-mt --cflags-only-I\" ] ] ] ;
.qtlibprefix = [ MATCH \"-L\\(.*\\)\" : string.join [ string.words [ SHELL \"pkg-config qt-mt --libs-only-L\" ] ] ] ;
.qtlinkflags = [ string.join [ MATCH \"-lqt-mt|(.*)\" : [ string.words [ SHELL \"pkg-config qt-mt --libs-only-l --libs-only-other\" ] ] ] : \" \" ] ;
lib qt-mt : <name>qt3 : : <include>$(.qtincprefix) 
   <library-path>$(.qtlibprefix)
   <cflags>$(.qtcompileflags)
   <cxxflags>$(.qtcompileflags)
   <linkflags>$(.qtlinkflags)
   <allow>qt-mt ;
```

**Note** that we don`t set HDR using `pkg-config qt-mt --cflags-only-I` for the generic case
because that includes ``-I``. 

==Internal Targets==

A feature of the library is that a target can only contain source artifacts from within the
same filesystem directory. The //butter// project has two main source directories, ``src/bouml``
and ``src/butter``. Here we will create a library for the bouml API classes in ``src/bouml`` and
the plug-out executable in ``src/butter``.

In package //API USER// I create an artifact ``bouml`` with stereotype **library**. The artifact 
is associated with all the //API USER// and //API BASE// artifacts as well as the ``qt`` library
artifact. The default library type was defined as **static** in the base project and I do not want
to override that here, so this library is defined.

In the //butter// package I create an artifact ``butter`` with stereotype **executable**. This 
is associated with the artifacts for //butter// classes and the ''main'' source. Additionally it
is associated to both the ``qt`` and the ``bouml`` libraries.

==Documents==

In addition to creating build files //butter// will also write any artifacts with the **document**
stereotype. I therefore create a README document artifact in the //Build// package.

==Build file headers==

The boost version of jam understands the concept of build variants. This is not present in the
other systems so we need a way to define settings specific to each style. Here I want to set 
some options that are only used in the //release// variant (//debug// is the default).  To do
this I create an artifact I called ``buildfile`` in the //Build// package containing what I want
to add.  After the initial generation of my desired build system I can then cut and paste from
this build file into an appropriate place in one of the build system artifacts. Any text that is
outside a section (a section is anything between a ``START`` and ``END`` tag) is left unchanged
when //butter// is run and is copied as-is into the generated file.  The example below shows
what I copied from the ``buildfile`` artifact into the ``Jamroot`` artifact.

```
##END: DATE
using gcc : : : <cxxflags>\"-std=c++98\"
  <linkflags>\"-rdynamic -lz\"
  <optimization>speed:<cxxflags>\"-march=native -mfpmath=sse -msse3\" ;

import string ;
project butter : requirements <variant>release:<cxxflags>\"-DNO_LOG -DNO_DBC\" ;
${butter_standard}
#  Build file for the butter project.
#
COMP = GNU ;
GUILIB = QT3 ;
# Signal use of the OPTIM flags instead of the DEBUG flags for release builds.
# I added \"-DNO_LOG -DNO_DBC\" to the optimisation flags in Jamrules
# DEBUG = OPTIM ;
DEBUG = DEBUG ;
${butter_make}
# Uncomment the following for release builds.
# USERFLAGS :=$(USERFLAGS) -DNO_LOG -DNO_DBC
##START: PREAMBLE
```

==Create the build system==

We have now defined our basic build system. We can no select any item that has 
the //butter// tool defined and select it. Note that //butter// always navigates 
to and runs from the base package regardless of where it is started.

Running the tool will give a result similar to the following, except here we have 
run it before so it only writes any changed documents.

```
Please wait: building target list for project butter.
Skipping unchanged build file : /tmp/butter/src/butter/makefile
Writing build file : /tmp/butter/src/bouml/makefile
Skipping unchanged build file : /tmp/butter/src/makefile
Skipping unchanged build file : /tmp/butter/makefile
Writing changed document : /tmp/butter/README.t2t
Skipping unchanged document : /tmp/butter/makefile.sys
```
==Review the style global definition file==

Note at the bottom of the trace in the last section it mentions the document ``makefile.sys``. 
Each style generates a document that contains global definitions specific to the working
of that specific style.  The **make** style creates this artifact called ``makefile.sys``,
the **standard** style would create a ``Jamrules`` artifact and **boost** would create a
``local.jam`` artifact.  The build system does not change these global definition file once 
created so they can be edited to add extra features and details.  If a mistake is made 
and the build system stops working, you can simply rename the current artifact and
a new default implementation will be generated. You can then re-add any changes from the
previous version (that work!).

Note that the //Build// package is not special, the program searches in packages
set to the determined build base directory for artifacts with these style
specific names and uses whatever is found. If an artifact is not found then one
with the default implementation is added to the first Deployment View at the
project base, creating the Deployment View if necessary. If no package exists
then it is also created (defaulting to being named ``Build``).

==Building the project==

All the created build systems attempt to ensure dependencies are met on a
per-target basis. However, inter-target dependencies are not considered when
generating the build system. In this regard **jam** and **boost jam** are much better
than **make** as they parse the entire build project and order builds to ensure
inter-target dependencies are satisfied. The make system handles this on a
directory-by-directory basis, but across directories is not handled (see make
[limitations #make_limit]).  Therefore to build the project we can use ``jam``
or ``bjam`` once, but must run ``make -k`` several times.

==Conclusion==

As our project continues we may add classes, change class (and artifact) names and so on. This
should be no problem, we simply rerun //butter// to update the build system.  //Butter// attempts
to provide enough flexibility that you can encapsulate all build information into the bouml 
project.  This should be a great help when sharing the project with other users and allows
you to version (CVS, subversion etc) everything in the project using only the data in the bouml 
project directory.
"
    end

    artifact 128042 "todo"
      comment "List of TODOs

* Validate new \"create_system\"
* Document limitations (bjam and linking)

DONE

"
    end

    artifact 155945 "local.jam"
      stereotype "document"
      comment "#
# local.jam
#
# Set constants for installation paths
path-constant VERSIONDIR : \"butter-1.0\" ;
path-constant PREFIX : installdir ;
path-constant EXEC_PREFIX : $(PREFIX) ;
path-constant BINDIR : $(EXEC_PREFIX)/bin ;
path-constant SBINDIR : $(EXEC_PREFIX)/sbin ;
path-constant LIBEXECDIR : $(EXEC_PREFIX)/libexec ;
path-constant LIBDIR : $(EXEC_PREFIX)/lib ;
path-constant DATAROOTDIR : $(PREFIX)/share ;
path-constant DATADIR : $(PREFIX)/share ;
path-constant SYSCONFDIR : /etc ;
path-constant SHAREDSTATEDIR : $(PREFIX)/com ;
path-constant LOCALSTATEDIR : $(PREFIX)/var ;
path-constant INCLUDEDIR : $(PREFIX)/include ;
path-constant LOCALEDIR : $(DATAROOTDIR)/locale ;
path-constant DOCDIR : $(DATAROOTDIR)/doc/$(VERSIONDIR) ;
path-constant INFODIR : $(DATAROOTDIR)/info ;
path-constant MANDIR : $(DATAROOTDIR)/man ;
path-constant HTMLDIR : $(DOCDIR) ;
path-constant DVIDIR : $(DOCDIR) ;
path-constant PDFDIR : $(DOCDIR) ;
path-constant PSDIR : $(DOCDIR) ;
path-constant MAN1DIR : $(MANDIR)/man1 ;
path-constant MAN2DIR : $(MANDIR)/man2 ;
path-constant MAN3DIR : $(MANDIR)/man3 ;
path-constant MAN4DIR : $(MANDIR)/man4 ;
path-constant MAN5DIR : $(MANDIR)/man5 ;
path-constant MAN6DIR : $(MANDIR)/man6 ;
path-constant MAN7DIR : $(MANDIR)/man7 ;
path-constant MAN8DIR : $(MANDIR)/man8 ;
path-constant MANNDIR : $(MANDIR)/mann ;
###############
## Editor sugar
###############
# Local Variables:
# mode: makefile
# End:

"
    end

    artifact 157097 "check-list.t2t"
      stereotype "document"
      associated_artifacts
      end
      comment "Acceptance checklist


| Acceptance tests                    | boost | standard | make |
| Build system creation |||
| Single directory, single target project   |  9  |  9  |   9   |
| Single directory, multiple target project |  9  |  9  |   9   |
| Multiple directory and target project     |  9  |  9  |   9   |
| Target inclusion |||
| Basic executable                          |  9  |  9  |   9   |*
| Basic static library                      |  9  |  9  |   9   |*
| Basic shared library                      |  9  | na  |   9   |*
| External library                          |  9  |  9  |   9   |*
| Non-standard target                       |  9  |  9  |   9   |*
| Document as non-C++ source                |  9  |  9  |   9   |*
| UML object property inclusion |||
| butter build-dir  : project               |  9  |  9  |  ni   |*
| butter base       : project               |  9  |  9  |   9   |*
| butter buildfile  : library               |  9  |  9  |   9   |*(other,external)
| butter compiler   : document              |  9a |  9a |   9   |*
|                   : executable            | xx  |  9  |   9   |*
|                   : library               | xx  |  9  |   9   |*
| butter flags      : project               |  9  |  9  |   9   |*
|                   : executable            |  9  |  9  |   9   |*
|                   : library               |  9  |  9  |   9   |*
|                   : source                |  9  |  9  |   9   |*
|                   : document              |  9  |  9  |   9   |*
| butter include    : project               |  9  |  9  |   9   |*
|                   : executable            |  9  |  9  |   9   |*
|                   : library               |  9  |  9  |   9   |*
|                   : source                |  9  |  9  |   9   |*
|                   : document              |  9  |  9  |   9   |*
| butter install    : executable, library   |  9  |  9  |   9   |*
|                   : document              |     |     |       |
| butter ldflags    : project               |  9  |  9  |   9   |*
|                   : executable, library   |  9  |  9  |   9   |*
|                   : source                |  9  |  9  |   9   |*
|                   : document              |  9  |  9  |   9   |*
| butter log-level  : project               |  9  |  9  |   9   |*
| butter other      : library               |  9  |  9  |   9   |*
| butter project    : library               |  9  |  9  |   9   |*
| butter style      : project               |  9  |  9  |   9   |*
| butter type       : library               |  9  | na  |   9   |*
|                   : project, package      |  9  | na  |   9   |*
| butter version    : project               |  9  |  9  |   9   |*

| UML object description inclusion |||
| Build file merging |||
| Existing artifact                         |     |
| Multiple artifacts                        |     |
| Error condition tests                     |     |
| Project read-only                         |     |
| Package read-only                         |  9  |
| Build file miss-edit                      |  9  |
| Build file not a document                 |  9  |
| Build file read-only                      |     |
| Unrecognised property                     |  9  |"
    end

    artifact 158249 "Jamfile"
      stereotype "document"
      comment "##START:version
#Butter project version 1.2
##END:version
##START:date
#Thu Sep 24 11:03:47 2009
##END:date
##START:preamble
SubDir TOP ;
HDRS += \"include/bouml\" ;
LINKLIBS += \"\" ;
C++FLAGS += \"-DWITHCPP\" ;
HDRS += \"include\" ;

##END:preamble
##START:target  src butter
SubInclude TOP src butter ;

##END:target  src butter
##START:target  src bouml
SubInclude TOP src bouml ;

##END:target  src bouml
"
    end

    artifact 158377 "Jamrules"
      stereotype "document"
      comment "#
# Default Jamrules
#

if $(UNIX)      { SUFSHR ?= .so ; }
else if $(NT)   { SUFSHR ?= .dll ; }

COMP ?= GNU ;

#############################
##
##  Default install locations
## 
#############################
VERSIONDIR = \"butter-1.0\" ;
PREFIX = installdir ;
EXEC_PREFIX = $(PREFIX) ;
BINDIR = $(EXEC_PREFIX)/bin ;
SBINDIR = $(EXEC_PREFIX)/sbin ;
LIBEXECDIR = $(EXEC_PREFIX)/libexec ;
LIBDIR = $(EXEC_PREFIX)/lib ;
DATAROOTDIR = $(PREFIX)/share ;
DATADIR = $(PREFIX)/share ;
SYSCONFDIR = /etc ;
SHAREDSTATEDIR = $(PREFIX)/com ;
LOCALSTATEDIR = $(PREFIX)/var ;
INCLUDEDIR = $(PREFIX)/include ;
LOCALEDIR = $(DATAROOTDIR)/locale ;
DOCDIR = $(DATAROOTDIR)/doc/$(VERSIONDIR) ;
INFODIR = $(DATAROOTDIR)/info ;
MANDIR = $(DATAROOTDIR)/man ;
HTMLDIR = $(DOCDIR) ;
DVIDIR = $(DOCDIR) ;
PDFDIR = $(DOCDIR) ;
PSDIR = $(DOCDIR) ;
MAN1DIR = $(MANDIR)/man1 ;
MAN2DIR = $(MANDIR)/man2 ;
MAN3DIR = $(MANDIR)/man3 ;
MAN4DIR = $(MANDIR)/man4 ;
MAN5DIR = $(MANDIR)/man5 ;
MAN6DIR = $(MANDIR)/man6 ;
MAN7DIR = $(MANDIR)/man7 ;
MAN8DIR = $(MANDIR)/man8 ;
MANNDIR = $(MANDIR)/mann ;

######################################################
##
##  Example definitions for compiler suite (TOOLSETS)
## 
######################################################
switch $(COMP)
{
case GNU :
CC = gcc ;
C++ = g++ ;
CCSTD = -std=c99 ;
C++STD = -std=c++98 ;
CCCPP = ;
C++CPP = ;
SHRFLAGS = -fpic ;
SHRLINKLIBS = -shared -rdynamic -ldl ;
ARCH = -march=native ;
CCOPTIMCOMP = -O2 $(ARCH) ;
C++OPTIMCOMP = -O2 $(ARCH) ;
CCDEBUGCOMP = -O0 -ggdb -DDEBUG=1 ; # -pedantic
C++DEBUGCOMP = -O0 -ggdb -DDEBUG=1 ; # -Weffc++
CCCOMP = -Wall $(CCSTD) $(CCCPP) ;
C++COMP = -Wall $(C++STD) $(C++CPP) ;
LINKCOMP = ;
}

################################################
##
##  Define the \"standard\" GUI flags
## 
################################################

CCGUI = ;
C++GUI = ;
LINKGUI = ;

switch $(GUILIB)
{
case GTKMM :
CCGUI = `pkg-config gtkmm-2.4 --cflags` ;
C++GUI = `pkg-config gtkmm-2.4 --cflags` ;
LINKGUI = `pkg-config gtkmm-2.4 --libs` ;

case MOTIF :
CCGUI = -I/usr/include ;
C++GUI = -I/usr/include ;
LINKGUI = -L/usr/lib -lXm -lXp -lXpm -lXmu -lXt -lXext -lX11 ;

case QT3 :
CCGUI = -I$(QTDIR)/include ;
C++GUI = -I$(QTDIR)/include ;
LINKGUI = -L$(QTDIR)/lib -lqt-mt -lXext -lX11 -lm ;

case * :
CCGUI = ;
C++GUI = ;
LINKGUI = ;

}

#################################
##
##  Define the \"standard\" flags
## 
#################################

CCFLAGS += $(CCCOMP) $(CCGUI) ;
C++FLAGS += $(C++COMP) $(C++GUI) ;
LINKLIBS += $(LINKCOMP) $(LINKGUI) ;

OPTIM = $(CCDEBUGCOMP) ;
OPTIM = $(C++DEBUGCOMP) ;

switch $(VARIANT)
{
case RELEASE :
OPTIM = $(CCOPTIMCOMP) ;
OPTIM = $(C++OPTIMCOMP) ;

}

LINKFLAGS = $(C++FLAGS) -lz ;
LINK = $(C++) ;

# Local Variables:
# mode: makefile
# End: 
"
    end
  end
end
