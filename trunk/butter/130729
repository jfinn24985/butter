format 66
"Build" // Build
  revision 40
  modified_by 41 "finnerty"
  // class settings
  //class diagram settings
  draw_all_relations default hide_attributes default hide_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_infonote default shadow default show_stereotype_properties default
  //use case diagram settings
  package_name_in_tab default show_context default auto_label_position default draw_all_relations default class_drawing_mode default shadow default show_stereotype_properties default
  //sequence diagram settings
  show_full_operations_definition default write_horizontally default class_drawing_mode default drawing_language default draw_all_relations default shadow default show_stereotype_properties default
  //collaboration diagram settings
  show_full_operations_definition default show_hierarchical_rank default write_horizontally default drawing_language default package_name_in_tab default show_context default draw_all_relations default shadow default show_stereotype_properties default
  //object diagram settings
   write_horizontally default package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default show_stereotype_properties default
  //component diagram settings
  package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default
  draw_component_as_icon default show_component_req_prov default show_component_rea default show_stereotype_properties default
  //deployment diagram settings
  package_name_in_tab default show_context default write_horizontally default auto_label_position default draw_all_relations default shadow default
  draw_component_as_icon default show_component_req_prov default show_component_rea default show_stereotype_properties default
  //state diagram settings
  package_name_in_tab default show_context default auto_label_position default write_trans_label_horizontally default show_trans_definition default draw_all_relations default shadow default
  show_activities default region_horizontally default drawing_language default show_stereotype_properties default
  //activity diagram settings
  package_name_in_tab default show_context default show_opaque_action_definition default auto_label_position default write_flow_label_horizontally default draw_all_relations default shadow default
  show_infonote default drawing_language default show_stereotype_properties default
  
  cpp_src_dir ".."
  comment "Project for project documentation and build files."
  deploymentview 130345 "config"
    //deployment diagram settings
    package_name_in_tab default show_context default write_horizontally default auto_label_position default draw_all_relations default shadow default
    draw_component_as_icon default show_component_req_prov default show_component_rea default show_stereotype_properties default
    artifact 141737 "README.t2t"
      stereotype "document"
      associated_artifacts
      end
      comment "The butter plugout
Butter Project (version 1.2: Beta 2)
October 2009


=Introduction=

Butter is a plug-out for generating a build system for (at the moment) C++ projects. It can 
produce build systems in three styles: Boost jam, standard jam and gnu make. (For people who 
have not used jam before, //butter// allows you to try it out before learning a new build-file 
syntax!)

The genpro tool is okay for single-target projects which use Qt, but limited if you have a medium
sized project with several dynamic libraries and executables.  I myself use bouml for a project
that has (currently) 8 or so libraries, 8 executables and 10 or so plugins.  Thankfully I found 
the boost jam build tool which makes building such a project easy.  However I found it 
frustrating that I could define all the build target information into bouml but could not 
write/convert that to anything.  Hence the //butter// project was conceived (because //butter//
goes well with jam!).

After writing the tool for boost jam files it was extended to create standard jam and gnu 
make files.  One of my original goals for adding make files was to allow me to build tarballs 
for projects, possibly with autoconf ``configure`` scripts that could be built by people 
that did not have boost jam.

This is the second beta release of the //butter// project. It is fully functional and a very 
useful tool, however not every situation has been tested. This could lead to complete failures
of the tool (the plugout starts then \"disappears\") or any errors that are reported may not make 
sense.  Please let me know your experiences of using this tool and any suggestions or feedback.

When built on unix systems in debug mode //butter// pauses with a dialog box at the start to allow
you to optionally attach a debugger.

==Generated build systems==

The generated build systems should produce equivalent targets. These are not necessarily 
identical and will not necessarily be located in the same place. Additionally, you can use
target types that are specific to a particular build system style.

==Important concepts, features and limitations==

- **build options**: The //butter// plugout creates a build system that has three basic 
build-system options (//default// (librarys/executables), //clean// and //install//) 
independent of build system style. However as boost ``jam`` does not have an independent 
install target (it performs installation as part of the default build) //butter// defines 
install targets only for the ``release`` variant, requiring ``bjam variant=release`` to 
build and install the project.
- **Style**: //butter// can produce build systems for several standard build tools. The build 
system for each style will produce equivalent, but not identical, results and not all options
are supported in all styles. The default style is //boost jam//.
- **Target**: A build target is an executable or library build target. In the UML these are 
represented as artifacts with the library or executable stereotype.
- **External target**: bouml allows you to define external classes, //butter// analogously 
allows you to create a library artifact (for external classes etc.) which can be associated
with a //normal// target to add the appropriate include and linker options.
- **Base directory**: The directory structure of the build system has to be singly rooted. This
is a limitation of the ``jam`` based build systems. 
- **Single-level source**: This tool has the limitation that all source UML artifacts of a 
target UML artifact must be in the same directory as the target. You can add static library
targets if you want source files in multiple directories to be used in a single application.
- **Multi-level target**: A target UML artifact need not be in the same directory as other 
target UML artifacts that use/reference it.
- **Target types**: In addition to library or executable types, //butter// allows you to use other 
targets types supported by the underlying build system (see documentation on [artifact properties #art_prop]), 
for example the extensive 
target types available with the Boost jam system. However, if users do not limit themselves to 
the default target types it becomes more difficult to switch between the different build styles.
- **Directory Names**: The name of a target's directory is used as its \"sub-project-name\" in 
the jam style. This means that when using a jam style all leaf directories must have unique names.
- **Documents**: The description from UML artifacts with the **document** stereotype can be
written to the filesystem by //butter//.  Documents with names that correspond to the
name of build files are specially handled by the program ([see below #buildfiles]. Additionally ``makefile.sys``,
``local.jam`` or ``Jamrules`` have special meaning for a particular build style ([see below #specialfiles]).
- **Mixed language programming**: [See below. #multi] Include a source file written 
in another language, such as fortran or C, as a //document// stereotype artifact 
in bouml which can also be associated with some relevant target.



===Boost jam limitations===[boost_limit]

The description field of external libraries can be used to give
detailed instructions for the build system ([see Artifact Description #desc_enc]).
This text can be searched for encoded flags or used as-is which may confuse
this style. This is resolved by using the generic section label which forces
the search for encoded flags.

For example if we want to use the boost filesystem library and use a
generic argument and we want to get the following in ``Jamroot``.
```
alias filesystem : : : : <linkflags>\"-lboost_filesystem\" ;
```
Using just the following results in the text
being placed as-is in ''Jamroot'' and therefore an error when we try to compile.
```
LINK=-lboost_filesystem
```
Instead using the generic section label forces the section to be treated as
containing encoded flags and gets us what we want.
```
${boost_generic}
LINK=-lboost_filesystem
```


===Jam standard limitations===

The ``standard`` ``jam`` program has the limitation that include 
directories and compilation flags are set globally for each compilation
directory.  This obviously means that the same set of 
compilation flags and include directories are seen by all targets
built from a single directory and is a serious limitation if you want 
two targets in the same directory to have conflicting flags.  Note this
limitation is not true for the linker flags which are always target 
specific. The plugout does attempt to merge the information from each 
target to remove duplicate information.

===Make limitations===[make_limit]

(1)  The current make style requires a make program (eg GNU make) that allows 
immediately assigned variables allowing constructs such as ``A:=$(A) -B -C``, 
which result in a cyclic dependency in standard make.

(2) The ``jam`` program manages dependencies for the entire project and correctly 
rebuilds all affected targets in the correct order.  The ``make`` style creates
makefiles were targets will be built in an arbitrary order.  This means that 
targets that depend on other targets (eg a source archive library) may not be 
updated correctly.  This means that you may need to run ``make`` several times 
before all targets are updated correctly even if no errors are reported.

For example, take the case of target //A// being dependent on target //B// 
in different directories and where //B// is build after //A//. The first ``make -k``
run will have an error for building //A// as it cannot find //B//. This is good 
as you can see that you must run ``make`` again.  So you call ``make -k`` again and
all is now updated correctly.  However, when you later make a change 
to //B// the next ``make`` run will rebuild //B// but not //A// as the old 
version of //B// will be seen when ``make`` checks target //A//.  Furthermore 
there will be no error message!  The only sure indication that all targets are 
updated is when a ``make`` run performs no actions.

==Future directions==

In this release of //butter// there is a simple //install// target type. It 
is intended that future releases will improve this capability with particular 
emphasis on producing systems designed for easy integration with the //autoconf// system.

People are free to contribute additional build system styles and make comments to improve the
existing styles.

- Possible future development.
 + A style for ```cmake``` or another similar program that generates portable makefiles.
 + Text replacement (optional?) : The plugout copies description text that it uses verbatim.
However, it might be useful to add a text replacement system similar to the rest of bouml.
 + Have a ``butter install`` property on a **document** artifact that will add the document
to the install target.
The //butter// plugout also does not directly support installation of files
generated by the documentation plugout.  This is because these files are
primarily developer documentation rather than user documentation. It might
be supported indirectly by defining a **document** artifact with the name
of the root-directory of the generated documentation and setting the 
``butter document`` property to ``nowrite`` and the ``butter install`` 
location to somewhere, such as ``DOCDIR``.



=Building butter=

The //butter// project contains the //butter// files and properties needed to create a 
build system for building //butter// itself.  However, to create your first butter version
you use the //genpro// tool on the ``butter.plugout`` artifact to create a ``qmake`` //pro//
file.

=Adding butter to bouml=

To use the //butter// tool, place the executable in the //bouml// directory containing 
the other tools.  Then in the //Tools//->//tools settings// dialog select the //Others//
tab and add something like the following:

|| Executable | display | Prj | 
| butter | Create build system | X | 


The //butter// plugout always operates on the entire project so it does not care where 
it is started. You can therefore add it to virtually any location. I activate it for the Prj as 
shown above as well as the next five columns (all the yellow folder icons) and under 
the artifact column.

=Quick Tutorial=

==Build Project==

The following example uses the //butter// bouml project as an example. In this project
we have five sub-packages:
- //Build// contains definitions for top-level/system build files of the base project. It 
also includes this README file. Its source location is ``..``
- //API BASE// contains the fixed part of the bouml plug-out API. Its header location is 
modified to be ``bouml`` and src location as ``../src/bouml``.
- //API USER// contains the user editable part of the bouml plug-out API. Its header 
location is ``bouml`` and src location as ``../src/bouml``, the same as the //API BASE//
package.
- //butter// contains the non-bouml-API related classes of the project. Its header location is 
``butter`` and src location is ``../src/butter``.
- //External// contains the references to external classes and libraries.


**TIP** I set the generation settings root directory to be ``/blah/blah/include`` and 
then each package as header = ``name``, source = ``../src/name``.  When combined with the
``#include : with root relative path`` you can create projects with source separated from
header files and need only include one ``-I`` include path. This is particularly useful 
when you want to create a library that other people may use as you can easily package up the
header files and require library clients to use only one ``-I`` include path for your
library.

==Initial set-up==

The //butter// system assumes that the bouml source root directory, as specified in the generation 
settings dialogue, is the root of the build system.  You can also use a user defined 
**butter base** property on the project package to define a relative path between this 
bouml root directory and some other desired build base directory.  However, if necessary the 
system will automatically reset the base directory to a directory that is a parent of all the 
source directories in the project. If no package exists at the base location the system will ask
for confirmation before creating such a package. 

In the example the generation settings root directory is ``[my-project]/include`` with each 
package header as ``[package]`` and package source directory as ``../src/[package]``.  I 
therefore need to specify the build base directory as the parent of the root directory with 
a user property on the base package:

```
butter base  : ..
```

We also need to define which style of build system to use. This is done by defining a
``butter style`` user property on the base package. If this is not defined then the
boost jam style is the default (it is also used whenever the style name is not 
recognised).

```
butter style : make
```

When using the boost jam style we can also define where we want the object files and targets
to be built using the ``butter build-dir`` property:

```
butter build-dir : build
```

The standard bouml plug-out project uses a single directory for all the header and source files.
I have modified this to use different directories for headers and source and also placed the
headers in a sub-directory of the generation root.  I have also defined 
``#include : with root relative path`` generation option. For includes directives automatically 
generated by bouml I need not do anything more, however many includes are manually defined 
in the //API BASE// and //API USER// packages.  I therefore need to add ``include/bouml`` as 
an include directory for all targets.

In addition I will be using definitions and settings specific to the C++ system. I therefore
need to define the ``-DWITHCPP`` flag for all targets.  Lastly, I have a multi-directory 
project but only want a single application so I therefore want to build all libraries targets as
static. To do this I set the following user properties on the base package:

```
butter flags : -DWITHCPP
butter include : include/bouml
butter type : static
```

==External library target==

The bouml API uses the QT3 library and this is used as the basis library for the //butter// 
project. I therefore need to define the include and linker options for this library. These could
be added to the project level options above, but then they would apply to all targets. A more
flexible way is to define a library artifact to act as a placeholder for external library in the
same way classes defined as external act as placeholders.  (Here I include these in a package
named //External// but the actual name is not significant to the system) Under the 
//External// package I define an artifact called //qt// which I set to have the library 
stereotype. I then mark it as an external library by defining the ``butter project`` user 
property:

```
butter project : qt3
```

I define the include and link options by setting the library description to:

```
${butter_generic}
HDR=${QTDIR}/include
LINK=-L${QTDIR}/lib -lqt-mt -lXext -lX11 -lm
```

The ``${butter_generic}`` is a section marker indicating the following description contains 
information that is used for all styles. The ``HDR=`` and ``LINK=`` obviously (also ``FLAGS=``)
define the include directories and link flags. Note that the include directories are the specified
as the directory names themselves.

===Style specific options===

Using the ``${butter_generic}`` marker gives //butter// information to translate into
each style.  However it is possible to provide definitions on a per-style basis.  A simple 
example is wanting to use one of the compile option configuration programs 
supplied with many libraries, in this case the standard method will not work for boost jam
so an alternative for that must be used.

```
${butter_generic}
FLAGS=`pkg-config qt-mt --cflags`
LINK=`pkg-config qt-mt --libs`
${butter_boost}
# This may not work, but given as an example
.qtcompileflags = [ string.join [ string.words [ SHELL \"pkg-config qt-mt --cflags-only-other\" ] ] : \" \" ] ;
.qtincprefix = [ MATCH \"-I\\(.*\\)\" : [ string.words [ SHELL \"pkg-config qt-mt --cflags-only-I\" ] ] ] ;
.qtlibprefix = [ MATCH \"-L\\(.*\\)\" : string.join [ string.words [ SHELL \"pkg-config qt-mt --libs-only-L\" ] ] ] ;
.qtlinkflags = [ string.join [ MATCH \"-lqt-mt|(.*)\" : [ string.words [ SHELL \"pkg-config qt-mt --libs-only-l --libs-only-other\" ] ] ] : \" \" ] ;
lib qt-mt : <name>qt3 : : <include>$(.qtincprefix) 
   <library-path>$(.qtlibprefix)
   <cflags>$(.qtcompileflags)
   <cxxflags>$(.qtcompileflags)
   <linkflags>$(.qtlinkflags)
   <allow>qt-mt ;
```

==Internal Targets==

A feature of the library is that a target can only contain source artifacts from within the
same filesystem directory. The //butter// project has two main source directories, ``src/bouml``
and ``src/butter``. Here we will create a library for the bouml API classes in ``src/bouml`` and
the plug-out executable in ``src/butter``.

In package //API USER// I create an artifact ``bouml`` with stereotype **library**. The artifact 
is associated with all the //API USER// and //API BASE// artifacts as well as the ``qt`` library
artifact. The default library type was defined as **static** in the base project and I do not want
to override that here, so this library is defined.

In the //butter// package I create an artifact ``butter`` with stereotype **executable**. This 
is associated with the artifacts for //butter// classes and the ''main'' source. Additionally it
is associated to both the ``qt`` and the ``bouml`` libraries.

==Documents==

In addition to creating build files //butter// will also write any artifacts with the **document**
stereotype. I therefore create a README document artifact in the //Build// package.

==Build file headers==

The boost version of jam understands the concept of build variants. This is not present in the
other systems so we need a way to define settings specific to each style. Here I want to set 
some options that are only used in the //release// variant (//debug// is the default).  To do
this I create an artifact I called ``buildfile`` in the //Build// package containing what I want
to add.  After the initial generation of my desired build system I can then cut and paste from
this build file into an appropriate place in one of the build system artifacts. Any text that is
outside a section (a section is anything between a ``START`` and ``END`` tag) is left unchanged
when //butter// is run and is copied as-is into the generated file.  The example below shows
what I copied from the ``buildfile`` artifact into the ``Jamroot`` artifact.

```
##END: DATE
using gcc : : : <cxxflags>\"-std=c++98\"
  <linkflags>\"-rdynamic -lz\"
  <optimization>speed:<cxxflags>\"-march=native -mfpmath=sse -msse3\" ;

import string ;
project butter : requirements <variant>release:<cxxflags>\"-DNO_LOG -DNO_DBC\" ;
${butter_standard}
#  Build file for the butter project.
#
COMP = GNU ;
GUILIB = QT3 ;
# Signal use of the OPTIM flags instead of the DEBUG flags for release builds.
# I added \"-DNO_LOG -DNO_DBC\" to the optimisation flags in Jamrules
# DEBUG = OPTIM ;
DEBUG = DEBUG ;
${butter_make}
# Uncomment the following for release builds.
# USERFLAGS :=$(USERFLAGS) -DNO_LOG -DNO_DBC
##START: PREAMBLE
```

==Create the build system==

We have now defined our basic build system. We can no select any item that has 
the //butter// tool defined and select it. Note that //butter// always navigates 
to and runs from the base package regardless of where it is started.

Running the tool will give a result similar to the following, except here we have 
run it before so it only writes any changed documents.

```
Please wait: building target list for project butter.
Skipping unchanged build file : /tmp/butter/src/butter/makefile
Writing build file : /tmp/butter/src/bouml/makefile
Skipping unchanged build file : /tmp/butter/src/makefile
Skipping unchanged build file : /tmp/butter/makefile
Writing changed document : /tmp/butter/README.t2t
Skipping unchanged document : /tmp/butter/makefile.sys
```
==Review the style global definition file==

Note at the bottom of the trace in the last section it mentions the document ``makefile.sys``. 
Each style generates a document that contains global definitions specific to the working
of that specific style.  The **make** style creates this artifact called ``makefile.sys``,
the **standard** style would create a ``Jamrules`` artifact and **boost** would create a
``local.jam`` artifact.  The build system does not change these global definition file once 
created so they can be edited to add extra features and details.  If a mistake is made 
and the build system stops working, you can simply rename the current artifact and
a new default implementation will be generated. You can then re-add any changes from the
previous version (that work!).

Note that the //Build// package is not special, the program searches in packages
set to the determined build base directory for artifacts with these style
specific names and uses whatever is found. If an artifact is not found then one
with the default implementation is added to the first Deployment View at the
project base, creating the Deployment View if necessary. If no package exists
then it is also created (defaulting to being named ``Build``).

==Building the project==

All the created build systems attempt to ensure dependencies are met on a
per-target basis. However, inter-target dependencies are not considered when
generating the build system. In this regard **jam** and **boost jam** are much better
than **make** as they parse the entire build project and order builds to ensure
inter-target dependencies are satisfied. The make system handles this on a
directory-by-directory basis, but across directories is not handled (see make
[limitations #make_limit]).  Therefore to build the project we can use ``jam``
or ``bjam`` once, but must run ``make -k`` several times.

==Conclusion==

As our project continues we may add classes, change class (and artifact) names and so on. This
should be no problem, we simply rerun //butter// to update the build system.  //Butter// attempts
to provide enough flexibility that you can encapsulate all build information into the bouml 
project.  This should be a great help when sharing the project with other users and allows
you to version (CVS, subversion etc) everything in the project using only the data in the bouml 
project directory.

=User Documentation=

The basic purpose of the //butter// project is to write non-source information
from the bouml project into the filesystem. The major operation is transforming
the target artifact objects into some sort of build file, in a similar way to the
//genpro// plugout. Additionally it combines all the targets to
generate a single set of build files for creating every target in the project.

The second major operation is to write //document// artifacts into the 
filesystem.  This is required by the ``standard`` and ``make`` styles so they
can write their global definition files into the bouml project, where the user
can subsequently edit them if necessary.  It also has the advantage that text 
files, such as ``README``, can be stored in the bouml project.

These two operations combine to allow every aspect of a project to be saved
within the bouml project.

==Project name and version==

The //butter// plugout uses the top-level package name as the project name. It 
also uses the optional user property \"butter version\" or \"version\" as the version number.
However, the most significant place this is used is the ``VERSIONDIR`` variable
in the [build settings file #specialfile] that will appear as document artifacts
in the bouml project.  Once created these files are not altered by the //butter//
project.  This allows you to add extra information to these files but will
not reflect changes to the version number of project name.  Therefore the
``VERSIONDIR`` may need to be manually changed when you change the version number.

==Locations==[location]

In bouml you can have several different packages specify the same filesystem directory 
for source files. The //butter// system uses the concept of a ``location`` to
associate a set of packages to a filesystem directory.

What this means for users
+ Packages with the same source filesystem location will be assigned to the
same location.  This means that only one of the packages will have a 
[``buildfile`` artifact #buildfile] which will include targets for all packages
at that location.  Additionally if ``buildfile``s exists in more than one of
the packages at a location then they will be merged and all but one deleted.
+ Source code for a single target must be at the same location as the target.
This is an intentional limitation of the design as it greatly simplifies the
generation of the ``buildfile``s. Furthermore I feel that a UML package
should be represented by at least one library or executable target. Targets
can be referenced across locations however.



==Build targets==

A central concept used in //butter// is that of a build target.  These are
defined to be UML artifact objects with the **library** or **executable**
stereotype and are translated into the obvious build targets.  Alternative
build targets (egboost jam`s **python-extension**) are supported by setting 
a property on a **library** artifact.

The source code and optionally dependent targets of a target are defined using 
the //Associated artifacts// of the target artifact.
Users should note the following considerations:
- Source artifacts for a target must be at the same [location #location] as
the target.  This is not checked by //butter// but will cause the build
process to fail with ``cannot find source file: XXXX`` errors.
- Associated library and executable artifacts need not be at the same location.
- Class dependencies are not checked (in this version). This means that the
user must manually add all artifacts to satisfy all dependencies.


===External libraries/targets===

In an analogous way to using //external// classes, you can create an artifact
for an //external// library. The //include//, //link// and //flags// definitions
for this artifact are then automatically added to //internal// targets that 
reference the //external// target.

==Installation feature==

All build targets are added to the default invocation of the build tool. In
addition an //install// target is supported.  Currently how the install target 
is invoked varies with each build style.  For the ``make`` style an //install//
target is added and must be called manually, for ``boost`` the installation 
occurs automatically for //release// variant builds.

One goal of the //butter// plugout is to facilitate project delivery as well
as building.  We assume that the project packaging is likely to be managed
by the GNU autoconf or similar tool.  To facilitate using such a tool each
style contains a set of variables for each installation target directory used 
by autoconf.  The names of these variables can be found by looking at one of 
the [special build files #specialfile]. For example the default variable used
for a **library** target is ``LIBDIR`` and for an **executable** target it
is ``BINDIR``.  The install location can be changed by setting the 
``butter install`` property of the target to the name of one of the other 
variables.


==Storing build information in bouml==

The //butter// plug-out uses three main mechanisms for encoding build
information into the the bouml project: user-defined Properties, Descriptions
and the description of specially named Artifacts. In general properties are used
for information that is used regardless of the build style.  Descriptions are
used for information that may need to be different for different styles but is
generally present in each style. Specially named artifacts are used to include
information specific to each style.

===Project package specific properties===

: butter style = boost | standard | jam
This names the style of build system you want to use. The **default** value is
``boost``. The other alternatives are ``standard`` (for standard jam) and 
``make``. If the name of the style is not recognised you get an error message
and the **default** style is used.
: butter base = [dir]
Indicates the relationship of the //desired// project root directory and the root directory 
set in C++ settings. For example I set the C++ root directory to be ``[real-root]/include`` and
set //butter base// to ``..`` (I also set the src directories to \"``../src/[name]``\").
This will be ignored if the directory is not a parent of all the source directories.
: butter build-dir = [dir]
Indicate a directory where the build files will be created. This is currently only
used by the ``boost`` style.


===Artifact properties===[art_prop]

Those properties with an (*) may be inherited from parent objects up to
and including the project, with //local// definitions overriding more
distant definitions. Properties with an (@) when
used on the project package are added to every build target, the project
level properties are combined with that of the target.  Properties
with an (#) may also be set in the target's description 
[see Artifact Descriptions #desc_enc].

: butter include = dir1 dir2 (@)(#)
A list of header directories to search for included files.  The list is
the bare directory name, ``-I`` will be prepended for those systems
that require it.
: butter flags = ... (@)(#)
A list of compiler options for building the object files. This is
used as-is.
: butter ldflags = ... (@)(#)
A list of linker options for building the target. This is
used as-is.
: butter install = ...
**Library** and **executable** targets are by default installed into the
``BINDIR`` and ``LIBDIR`` install locations. To install in a different location
set this property to one of the other install directory names. If
you do not want the target installed set it to ``NONE``.
: butter type = static | shared (*)
Indicate whether a library target is to be build as a static code archive
or a dynamic library.


: butter project = [name]
For **library** stereotype artifacts only. This indicates that the artifact
represents an //external// library that will not be build but associated
with other targets.  In this target the //include//, //flag// and //link//
definitions are those for the //external// library and are automatically
added to //internal// targets that reference this //external// target.

For the ``boost`` style, ``[name]`` is used to group external projects which
have the same external project name.
: butter other = [name]
For **library** stereotype artifacts only. This indicates that the artifact
represents an alternate build target. These are build style specific:
 - boost | standard : Used as-is as the jam rule name.
 - make : ``$(NAME_IN_UPPERCASE)`` used as the target build tool.
The definition for what these do must be defined by the user or 
must be already present in the build systems.
: butter buildfile = [name]
For **library** stereotype artifacts with //butter other// property only.
This indicates an external file that contains definitions to use
for this //external// library.
 - boost : Adds ``using [name] ;``
 - standard : Adds ``include [name].jam ;``
 - make : Adds ``include [name].make``


: butter document : nowrite
For **document** stereotype artifacts only. This indicates that the document
should not be written to disk. By default //butter// will write all
documents to disk.



===Artifact Descriptions===[desc_enc]

The //butter// plugout can use the description from target artifacts 
to store generic or style-specific build information. It uses section
markers that look like the replacement markers used in bouml, namely
``${butter_generic}`` for the section containing generic information.
Each style has a section marker defined as ``${butter_`` + style name + ``}``.

Firstly the description is divided into sections by the markers and 
the active section is defined by the following rules:

+ no section marker = use entire description content
+ style specific marker = use marked section
+ generic marker = if no specific section and generic marker is
 present, use the generic section.
+ markers present but not generic or for this style = empty section.


Once a section has been discovered it is searched for lines containing
the following definition labels.
```
HDR=
FLAGS=
LINK=
```
which are converted to //include//, //flag// and //link// definitions. These
are used in exactly the same way as the corresponding properties above.

For //external// library targets if the definition labels are present then 
the rest of the section is ignored. If none of the 
labels are present then the section is written as-is into the build file.


===Artifacts named Jamfile/Jamroot/makefile===[buildfile]

Artifacts with the **document** stereotype and with the 
style specific build file name are considered to contain header 
text in their //descriptions// for the build file at the current 
location the first time //butter// is run. If such documents are 
present in several packages for the same location then they are
merged and all but one is delete. Once //butter// has been run
these artifacts will contain sections of text between start/end markers
that were generated by //butter//. Text outside these section markers will
not be changed when //butter// is rerun, unlike the text within the
sections.

Any text outside the section markers is associated with 
the following section by //butter//.  This makes it possible to add target
specific information without worrying about the order that targets appear.
However, it does mean that text preceding a target will be deleted if
the target is deleted.


==Build style special artifacts==[specialfile]

Each styles uses a file containing global definitions located at the 
top-level project directory. An artifact with the content of such a
file is created in the bouml project in a package set to that directroy
the first time //butter// is run 
for that styles. Once created these named artifacts will be reused on 
later //butter// runs, allowing the user to edit the content if desired.

**Note** that if one of these files exist in the project directory already 
it will be overwritten by the //butter// plugout.

The names of these build files are:

|| style | filename
| ``make`` | //makefile.sys//
| ``standard`` | //Jamrules//
| ``boost`` | //local.jam//


The content of these files, particularly //makefile.sys//, is essential
for the correct operation of the generated build system.  Therefore, care
should be taken when editing these artifacts in bouml. If something does
go wrong then simply renaming the artifact in bouml will cause a fresh
default version to be created.

The default contents of these files (as generated by //butter//) are intended
only as starting points.  It is recommended that you edit these to match your 
needs.  Because //butter// will use artifacts with these names it is 
possible to add these artifacts to a template bouml project with your 
other tailered settings.

=Advanced usage=[advanced]

==Documentation/man pages==

Let us assume that you have the text for a man page written in txt2tags markup
in **document** artifact ``butter.t2t`` and also you have a ``man`` build rule 
for converting the document to a man page.  To convert the artifact to a man 
page and have it installed we create a **library** artifact ``butter.1`` and 
associate ``butter.t2t`` to it. We then set the following properties on the new
**library** artifact:
| butter other: | man
| butter install: | MAN1




==Multi-language programming==[multi]

Tools other than //bouml// are probably better for writing in procedural
languages like C and Fortran.  It is sometimes useful to use these
languages in a predominantly C++ program: to better utilise libraries
written in these languages, or to provide an interface to your C++ project
in these languages, or to provide (possibly) better performance for
maths-intensive operations. While, //bouml// does not directly support this,
it is can now be done easily with the help of //butter//.

* Create a artifact with the //document// stereotype and the source filename,
eg \"c_interface.c\", \"c_interface.h\" or \"matrix_ops.F\".
* Write the source code directly into the document's description field.
* Include the document in a //library// or //executable// artifact as
if it was a normal source file.
* (Also ensure that the needed compilation settings are in the [global buildfile #specialfile]!)


When //butter// is run, the documents containing the unsupported langauge will
be written to disk and can then be compiled along with the C++ source.  Special
build instructions can also be included using a [//buildfile// document #buildfile].

"
    end

    artifact 128042 "todo"
      comment "List of TODOs
"
    end
  end
end
