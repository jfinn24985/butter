class bjam_writer
!!!167977.cpp!!!	build_system(in a_top_loc : location) : void
#line 101
// Perform the write in a depth-first manner.
if (a_top_loc.children().count () > 0)
{
  for (unsigned int l_i (0); l_i < a_top_loc.children().count (); ++l_i)
  {
    build_system (*(a_top_loc.children().at (l_i)));
  }
}

// Check that the directroy exists
QDir l_target_dir (a_top_loc.full_path ());
if (not l_target_dir.exists ())
{
  l_target_dir.mkdir (a_top_loc.full_path ());
}
// Create the pathname for the current location.
QCString l_full_path (a_top_loc.full_path ());
l_full_path += QDir::separator ();
l_full_path += (NULL == a_top_loc.parent () ? root_name () : default_name ());
QString l_buffer;
{
  // Scope for l_os
  QTextOStream l_os (&l_buffer);
#ifndef NO_LOG
  l_os << comment () << " BEGIN jamfile [" << l_full_path << "]\n";
#endif
  if (a_top_loc.templates().count () > 0)
  {
#ifndef NO_LOG
    l_os << comment () << " This build files uses the following templates:\n";
#endif
    for (unsigned int l_i (0); l_i < a_top_loc.templates().count (); ++l_i)
    {
#ifndef NO_LOG
      l_os << comment () << " [" << l_i << "] = " << a_top_loc.templates().at (l_i)->name () << "\n";
#endif
      use_template (*(a_top_loc.templates().at (l_i)), l_os);
    }
  }
// Write some header documentation
#ifndef NO_LOG
  if (a_top_loc.packages().count () > 0)
  {
    l_os << comment () << " This build file contains the following packages:\n";
    for (unsigned int l_i (0); l_i < a_top_loc.packages().count (); ++l_i)
    {
      l_os << comment () << " [" << l_i << "] = " << a_top_loc.packages().at (l_i)->name () << "\n";
    }
    l_os << "\n";
  }
#endif
// Write any initialisation stuff
  initialise (a_top_loc, l_os);

// Write top-level stuff
  if (NULL == a_top_loc.parent ())
  {
    top_level (a_top_loc, l_os);
  }

// Standard targets
  if (a_top_loc.targets().count () > 0)
  {
#ifndef NO_LOG
    l_os << comment () << " Targets:\n";
#endif
    for (unsigned int l_i (0); l_i < a_top_loc.targets().count (); ++l_i)
    {
#ifndef NO_LOG
      l_os << comment () << " [" << l_i << "] = " << a_top_loc.targets().at (l_i)->name () << "\n";
#endif
      target (*(a_top_loc.targets().at (l_i)), l_os);
    }
    l_os << "\n";
  }

// Sub locations.
  if (a_top_loc.children().count () > 0)
  {
#ifndef NO_LOG
    l_os << comment () << " Children:\n";
#endif
    for (unsigned int l_i (0); l_i < a_top_loc.children().count (); ++l_i)
    {
#ifndef NO_LOG
      l_os << comment () << " [" << l_i << "] = " << a_top_loc.children().at (l_i)->path () << "\n";
#endif
      sublocation (*(a_top_loc.children().at (l_i)), l_os);
    }
    l_os << "\n";
  }

  // Now check for installable documents.
  if (not a_top_loc.documents ().isEmpty ())
  {
    for (unsigned int l_i (0); l_i < a_top_loc.documents ().count (); ++l_i)
    {
      QCString l_install_dir;
      if (a_top_loc.documents ().at (l_i)->propertyValue (item_traits::butter_install_name, l_install_dir))
      {
        install_target (*a_top_loc.documents ().at (l_i), l_install_dir, l_os);
      }
    }
  }

#ifndef NO_LOG
  l_os << "# END jamfile [" << l_full_path << "]\n";
#endif
}

// We have created the contents of the file in l_buffer
// Check that the file has changed..
if (not compare_file_to_string (l_full_path, QCString(l_buffer)))
{
  UmlCom::trace ("<p>Writing build file : " + l_full_path + "</p>");
}
else
{
  UmlCom::trace ("<p>Skipping unchanged build file : " + l_full_path + "</p>");
}

// Now write any documents.
if (not a_top_loc.documents ().isEmpty ())
{
  write_documents (a_top_loc);
}
!!!152361.cpp!!!	external_target(in a_project : string, inout a_target : UmlArtifact, inout a_os : ostream) : void
// Construct a mini-project section.
bool l_is_using (false);
a_os << "#\n# Section for project: " << a_project << "\n#\n";
QString l_os_buf;
QTextOStream l_os (&l_os_buf);
l_os << "project " << a_project << " ;\n";
for (unsigned int l_i (0); l_i < a_target.count (); ++l_i)
{
  UmlArtifact *l_item (a_target.at (l_i));
  BUTTER_CHECK (NULL != l_item, "nul item in external target vector.");
  QCString l_tmp;
  if (l_item->propertyValue (item_traits::butter_buildfile_name, l_tmp))
  {
    // This is a using directive; all definitions are assumed to be in the 
    // given jamfile
    a_os << "using " << l_tmp << " ;\n";
    l_is_using = true;
    break;
  }
  else
  {
    QCString l_tmpl (section (section_name, l_item->description ()));
    if (not l_tmpl.isEmpty ())
    {
      l_os << l_tmpl << "\n";
    }
    else
    {
      QCString l_hdr, l_link, l_flags;
      find_hdr_link (l_item->description (), l_hdr, l_link, l_flags);
      if (not (l_hdr.isEmpty ()and l_link.isEmpty ()))
      {
        l_os << "alias " << l_item->name () << " : : : : ";
        if (not l_hdr.isEmpty ())
        {
          l_os << "<include>\"" << l_hdr << "\" ";
        }
        if (not l_link.isEmpty ())
        {
          l_os << "<linkflags>\"" << l_link << "\" ";
        }
        if (not l_flags.isEmpty ())
        {
          l_os << "<cxxflags>\"" << l_flags << "\" ";
        }
        l_os << ";\n\n";
      }
    }
  }
}

if (not l_is_using)
{
  a_os << l_os_buf.data ();
}
!!!158505.cpp!!!	initialise(in a_location : location, inout a_buffer : ostream) : void
if (NULL != a_location.parent () and a_location.has_targets ())
{
  // Add definitions for sub-project to be added to the
  // top-level locations
  QString l_tmp;
  QTextOStream l_os (&l_tmp);
  // use-project /compchem/chemistry : src/chemistry ;
  l_os << "use-project /" << project_name () << "/";
  // Build path from parent locations.
  QCString l_path (a_location.path ());
  for (location * l_top (a_location.parent ()); l_top->parent () != NULL; l_top = l_top->parent ())
  {
    l_path.insert (0, QDir::separator ());
    l_path.insert (0, l_top->path ());
  }
  l_os << l_path << " : " << l_path << " ;\n";
  m_project_buffer.append (l_tmp);
}
!!!174249.cpp!!!	install_target(in a_target : UmlArtifact, in a_loc_var : string, inout a_os : ostream) : void
if (a_loc_var != item_traits::no_install_value)
{
  a_os << "install install_target : " << const_cast< UmlArtifact& >(a_target).name ();
  a_os << " : <variant>release <location>$(" << a_loc_var;
  a_os << ") ;\ninstall install_target : : <variant>debug ;\n\n";
}
!!!149161.cpp!!!	requirements(in a_item : UmlItem, inout a_reqs : string) : bool
bool Result (false);
QCString l_tmp;
QString l_section;
QTextOStream l_os (&l_section);
if (const_cast< UmlItem& >(a_item).propertyValue (item_traits::butter_include_name, l_tmp))
{
  Result = true;
  QStringList l_list (QStringList::split (" ", l_tmp));
  for (unsigned int l_i (0); l_i < l_list.count (); ++l_i)
  {
    l_os << "<include>\"" << (*l_list.at (l_i)).stripWhiteSpace () << "\" ";
  }
  l_os << "\n\t";
}
if (const_cast< UmlItem& >(a_item).propertyValue (item_traits::butter_ldflags_name, l_tmp))
{
  Result = true;
  l_os << "<linkflags>\"" << l_tmp << "\"\n\t";
}
if (const_cast< UmlItem& >(a_item).propertyValue (item_traits::butter_flags_name, l_tmp))
{
  Result = true;
  l_os << "<cxxflags>\"" << l_tmp << "\"\n\t";
}
if (Result)
{
  a_reqs = l_section;
}
return Result;
!!!153001.cpp!!!	sublocation(in a_location : location, inout a_os : ostream) : void
a_os << "build-project " << a_location.path () << " ;\n";
!!!152873.cpp!!!	target(in a_target : UmlArtifact, inout a_os : ostream) : void
#line 300
const QCString l_stereotype (const_cast< UmlArtifact& >(a_target).stereotype ());
QVector < UmlArtifact > l_assoc0 (const_cast< UmlArtifact& >(a_target).associatedArtifacts ());
if (not l_assoc0.isEmpty ())
{
  bool Result (true);
// a_target must be execution or library stereotype
  QCString l_lib_type;
  QCString l_install_dir;
  if (l_stereotype == item_traits::library_stereotype)
  {
    QCString l_other;
    if (const_cast< UmlArtifact& >(a_target).propertyValue (item_traits::butter_other_name, l_other))
    {
      a_os << l_other << " ";
    }
    else
    {
      a_os << "lib ";
    }
    if (not item_traits::property_search (a_target, item_traits::butter_lib_type_name, l_lib_type))
    {
      l_lib_type = item_traits::static_value;
    }
    if (not const_cast< UmlArtifact& >(a_target).propertyValue (item_traits::butter_install_name, l_install_dir))
    {
      l_install_dir = item_traits::libdir_value;
    }
  }
  else if (l_stereotype == item_traits::executable_stereotype)
  {
    a_os << "exe ";
    if (not const_cast< UmlArtifact& >(a_target).propertyValue (item_traits::butter_install_name, l_install_dir))
    {
      l_install_dir = item_traits::bindir_value;
    }
  }
  else
  {
    Result = false;
  }
  if (Result)
  {
    a_os << const_cast< UmlArtifact& >(a_target).name () << " :\n\t";
    for (unsigned int l_i (0); l_i < l_assoc0.size (); ++l_i)
    {
      UmlArtifact *l_tmp (l_assoc0.at (l_i));
      if (l_tmp->stereotype () == item_traits::library_stereotype)
      {
        QCString l_pack;
        if (l_tmp->propertyValue (item_traits::butter_project_name, l_pack))
        {
          a_os << "/" << l_pack << "//";
        }
        else
        {
          a_os << "/" << project_name () << "/" << item_traits::location (*l_tmp) << "//";
        }
        a_os << l_tmp->name () << "\n\t";
      }
      else if (l_tmp->stereotype () == item_traits::source_stereotype)
      {
        a_os << l_tmp->name () << "." << CppSettings::sourceExtension () << "\n\t";
      }
    }
    a_os << ":\n\t";
    if (not l_lib_type.isEmpty ())
    {
      a_os << "<link>" << l_lib_type << "\n\t";
    }
    QCString l_tmp;
    if (requirements (a_target, l_tmp))
    {
      a_os << l_tmp;
    }
    a_os << ";\n\n";
    if (not l_install_dir.isEmpty ())
    {
      install_target (a_target, l_install_dir, a_os);
    }
  }
}
!!!152745.cpp!!!	top_level(in a_loc : location, inout a_os : ostream) : void
BUTTER_REQUIRE (NULL == a_loc.parent (), "top-level can only be called on the top-most location");
QCString l_tmp;

a_os << "# Include local constants\ninclude " << s_rules_name << " ;\n\n";
a_os << "project " << project_name ();
a_os << "\n\t: requirements ";
if (requirements (m_project, l_tmp))
{
   a_os << l_tmp;
}
a_os << "<include>\"" << item_traits::hdrname (m_project).path ().mid (a_loc.full_path ().count ()) << "\" :\n\t";
if (const_cast< UmlPackage & > (m_project).propertyValue (item_traits::butter_build_dir_name, l_tmp))
{
 a_os << ": build-dir " << l_tmp <<"\n\t";
}
a_os << ";\n#\n# Define sub-projects.\n#\n" << m_project_buffer;
// Write external projects
if (not location::external_targets().isEmpty ())
{
  for (QDictIterator < QVector < UmlArtifact > > l_i (location::external_targets ()); l_i.current (); ++l_i)
  {
    external_target (QCString (l_i.currentKey ()), *(l_i.current ()), a_os);
  }
}
// If no makefile docs...
if (not a_loc.has_document (s_rules_name))
{
  // Find deployment view.
  QCString l_ver;
  if (not const_cast< UmlPackage & > (m_project).propertyValue (item_traits::butter_version_name, l_ver))
  {
    if (not const_cast< UmlPackage & > (m_project).propertyValue (item_traits::version_name, l_ver))
    {
      l_ver = "1.0";
    }
  }
  QCString l_default_rules (s_default_rules);
  int l_i (0);
  const QCString l_project ("@@project@@");
  const QCString l_version ("@@version@@");
  if (-1 != (l_i = l_default_rules.find (l_project)))
  {
    l_default_rules.replace (l_i, l_project.length (), const_cast< UmlPackage & > (m_project).name ());
  }
  if (-1 != (l_i = l_default_rules.find (l_version)))
  {
    l_default_rules.replace (l_i, l_version.length (), l_ver);
  };
  const_cast<location&>(a_loc).create_document (s_rules_name)->set_Description (l_default_rules);
}
!!!152617.cpp!!!	use_template(in a_art : UmlArtifact, inout a_os : ostream) : void
a_os << section (section_name, const_cast< UmlArtifact& >(a_art).description ());
