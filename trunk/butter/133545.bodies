class bjam_writer
!!!153001.cpp!!!	descendent_link(inout a_art : compound_artifact, in a_loc : location) : void
// Add ourself to the system artifact (if not the top-level).
if (NULL != a_loc.parent ())
{
  QString tmp_;
  QTextOStream os_ (&tmp_);
  // Build SubDir.
  const location *loc_cursor_ = &a_loc;
  QString dir_line_;
  while (NULL != loc_cursor_->parent ())
  {
    if (not dir_line_.isEmpty ())
    {
      dir_line_.insert (0, QDir::separator ());
    }
    dir_line_.insert (0, loc_cursor_->path ());
    loc_cursor_ = loc_cursor_->parent ();
  }
  // Add definition for this sub-project to the top-level location
  // use-project /compchem/chemistry : src/chemistry ;
  os_ << "use-project /" << project_name_ << "/" << a_loc.path () << " : " << dir_line_ << " ;\n";
  // build-project src/chemistry ;
  os_ << "build-project " << dir_line_ << " ;\n\n";
  system_artifact_->close.second.append (tmp_);
}
!!!152361.cpp!!!	external_target(in a_current : location, in a_target : UmlArtifact) : void
// Get project name, if present
QCString value_;
const_cast< UmlArtifact& >(a_target).propertyValue (item_traits::butter_project_name, value_);
BUTTER_CHECK (not value_.isEmpty (), "Programming error, should not be in external_target if project attribute is not set on artifact.");
// Get the external target section
butter::compound_artifact::string_pair_t & proj_ (system_artifact_->target (value_));
// Construct a mini-project section.
if (proj_.second.isEmpty ())
{
  proj_.second.append ("#\n# Section for project: " + value_ + "\n#\nproject " + value_ + " ;\n");
}
// If this is a using directive - we don't need to do anything
if (not proj_.second.contains ("using "))
{
  QCString tmp_;
  if (const_cast< UmlArtifact& >(a_target).propertyValue (item_traits::butter_buildfile_name, tmp_))
  {
    // This is a using directive; all definitions are assumed to be in the 
    // given jamfile -> reset string
    proj_.second = QCString ("#\n# Section for project: " + value_ + "\n#\nproject " + value_ + " ;\nusing " + tmp_ + " ;\n");
  }
  else
  {
    QCString template_ (section (section_name, const_cast< UmlArtifact& >(a_target).description ()));
    if (not template_.isEmpty ())
    {
      proj_.second.append (template_ + "\n");
    }
    else
    {
      QCString includes_, linkflags_, cflags_;
      find_hdr_link (const_cast< UmlArtifact& >(a_target).description (), includes_, linkflags_, cflags_);
      if (not (includes_.isEmpty ()and linkflags_.isEmpty ()))
      {
        proj_.second.append ("alias " + const_cast< UmlArtifact& >(a_target).name () + " : : : : ");
        if (not includes_.isEmpty ())
        {
          proj_.second.append ("<include>\"" + includes_ + "\" ");
        }
        if (not linkflags_.isEmpty ())
        {
          proj_.second.append ("<linkflags>\"" + linkflags_ + "\" ");
        }
        if (not cflags_.isEmpty ())
        {
          proj_.second.append ("<cxxflags>\"" + cflags_ + "\" ");
        }
        proj_.second.append (";\n\n");
      }
    }
  }
}
!!!152745.cpp!!!	initialise(inout a_base : location, in a_project : UmlItem) : void
BUTTER_REQUIRE (NULL == a_base.parent (), "initialise can only be called on the top-most location");
project_name_ = const_cast< UmlItem& >(a_project).name ();
QCString prop_value_;
QString content_;
bool req_set_ (false);
const QString base_include_ (item_traits::hdrname (dynamic_cast< const UmlPackage& >(a_project)).path ().mid (a_base.full_path ().count ()));
QTextOStream os_ (&content_);
os_ << "# Include local constants\ninclude " << s_rules_name << " ;\n\n";
os_ << "project " << project_name_;
os_ << "\n\t: ";
if (requirements (a_project, prop_value_))
{
  req_set_ = true;
  os_ << "requirements " << prop_value_;
}
if (not base_include_.isEmpty ())
{
  if (not req_set_)
  {
    os_ << "requirements ";
  }
  os_ << "<include>\"" << base_include_ << "\" :\n\t";
}

if (const_cast< UmlItem & > (a_project).propertyValue (item_traits::butter_build_dir_name, prop_value_))
{
 os_ << ": build-dir " << prop_value_ <<" ;\n";
}
else
{
  os_ << ": ;\n";
}
system_artifact_->preamble.second = content_;

// If no local definitions doc...
if (a_base.find_uml_document (s_rules_name).isEmpty ())
{
  // Find deployment view.
  QCString l_ver;
  if (not const_cast< UmlItem & > (a_project).propertyValue (item_traits::butter_version_name, l_ver))
  {
    if (not const_cast< UmlItem & > (a_project).propertyValue (item_traits::version_name, l_ver))
    {
      l_ver = "1.0";
    }
  }
  QCString l_default_rules (s_default_rules);
  int l_i (0);
  const QCString l_project ("@@project@@");
  const QCString l_version ("@@version@@");
  if (-1 != (l_i = l_default_rules.find (l_project)))
  {
    l_default_rules.replace (l_i, l_project.length (), project_name_);
  }
  if (-1 != (l_i = l_default_rules.find (l_version)))
  {
    l_default_rules.replace (l_i, l_version.length (), l_ver);
  };
  a_base.create_uml_document (s_rules_name)->set_Description (l_default_rules);
}
!!!174249.cpp!!!	install_target(in a_target : UmlArtifact, in a_loc_var : string, inout a_os : ostream) : void
if (a_loc_var != item_traits::no_install_value)
{
  a_os << "install install_target : " << const_cast< UmlArtifact& >(a_target).name ();
  a_os << " : <variant>release <location>$(" << a_loc_var;
  a_os << ") ;\ninstall install_target : : <variant>debug ;\n\n";
}
!!!152873.cpp!!!	local_target(in a_current : location, in a_target : UmlArtifact, inout a_localdoc : compound_artifact) : void
#line 300
QPtrVector < UmlArtifact > assoc_arts_ (const_cast< UmlArtifact& >(a_target).associatedArtifacts ());
if (not assoc_arts_.isEmpty ())
{
  butter::compound_artifact::string_pair_t & output_ = a_localdoc.target (const_cast< UmlArtifact& >(a_target).name ());
  QString tmp_;
  QTextOStream os_ (&tmp_);
  const QCString stereotype_ (const_cast< UmlArtifact& >(a_target).stereotype ());
  bool Result (true);
// a_target must be execution or library stereotype
  QCString lib_stat_or_shar_;
  QCString install_dir_;
  if (stereotype_ == item_traits::library_stereotype)
  {
    QCString other_target_type_;
    if (const_cast< UmlArtifact& >(a_target).propertyValue (item_traits::butter_other_name, other_target_type_))
    {
      os_ << other_target_type_ << " ";
    }
    else
    {
      os_ << "lib ";
    }
    if (not item_traits::property_search (a_target, item_traits::butter_lib_type_name, lib_stat_or_shar_))
    {
      lib_stat_or_shar_ = item_traits::static_value;
    }
    if (not const_cast< UmlArtifact& >(a_target).propertyValue (item_traits::butter_install_name, install_dir_))
    {
      install_dir_ = item_traits::libdir_value;
    }
  }
  else if (stereotype_ == item_traits::executable_stereotype)
  {
    os_ << "exe ";
    if (not const_cast< UmlArtifact& >(a_target).propertyValue (item_traits::butter_install_name, install_dir_))
    {
      install_dir_ = item_traits::bindir_value;
    }
  }
  else
  {
    Result = false;
  }
  if (Result)
  {
    os_ << const_cast< UmlArtifact& >(a_target).name () << " :\n\t";
    for (unsigned int l_i (0); l_i < assoc_arts_.size (); ++l_i)
    {
      UmlArtifact *l_tmp (assoc_arts_.at (l_i));
      if (l_tmp->stereotype () == item_traits::library_stereotype)
      {
        QCString l_pack;
        if (l_tmp->propertyValue (item_traits::butter_project_name, l_pack))
        {
          os_ << "/" << l_pack << "//";
        }
        else
        {
          os_ << "/" << project_name_ << "/" << item_traits::location (*l_tmp) << "//";
        }
        os_ << l_tmp->name () << "\n\t";
      }
      else if (l_tmp->stereotype () == item_traits::source_stereotype)
      {
        os_ << l_tmp->name () << "." << CppSettings::sourceExtension () << "\n\t";
      }
    }
    os_ << ":\n\t";
    if (not lib_stat_or_shar_.isEmpty ())
    {
      os_ << "<link>" << lib_stat_or_shar_ << "\n\t";
    }
    QCString l_tmp;
    if (requirements (a_target, l_tmp))
    {
      os_ << l_tmp;
    }
    os_ << ";\n\n";
    if (not install_dir_.isEmpty ())
    {
      install_target (a_target, install_dir_, os_);
    }
  }
  output_.second = tmp_;
}
!!!149161.cpp!!!	requirements(in a_item : UmlItem, inout a_reqs : string) : bool
bool Result (false);
QCString l_tmp;
QString l_section;
QTextOStream l_os (&l_section);
if (const_cast< UmlItem& >(a_item).propertyValue (item_traits::butter_include_name, l_tmp))
{
  Result = true;
  QStringList l_list (QStringList::split (" ", l_tmp));
  for (unsigned int l_i (0); l_i < l_list.count (); ++l_i)
  {
    l_os << "<include>\"" << (*l_list.at (l_i)).stripWhiteSpace () << "\" ";
  }
  l_os << "\n\t";
}
if (const_cast< UmlItem& >(a_item).propertyValue (item_traits::butter_ldflags_name, l_tmp))
{
  Result = true;
  l_os << "<linkflags>\"" << l_tmp << "\"\n\t";
}
if (const_cast< UmlItem& >(a_item).propertyValue (item_traits::butter_flags_name, l_tmp))
{
  Result = true;
  l_os << "<cxxflags>\"" << l_tmp << "\"\n\t";
}
if (Result)
{
  a_reqs = l_section;
}
return Result;
