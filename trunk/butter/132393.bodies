class location
!!!143273.cpp!!!	add_artifact(in a_art : UmlArtifact) : void
QCString l_tmp;
const QCString l_name (const_cast< UmlArtifact& >(a_art).name ());
const QCString l_stereotype (const_cast< UmlArtifact& >(a_art).stereotype ());
if (const_cast< UmlArtifact& >(a_art).propertyValue (item_traits::butter_project_name, l_tmp))
{
  // Is an external target for project 'l_tmp'.
  QVector< UmlArtifact > * l_ext (s_ext_targets.find (l_tmp));
  if (NULL == l_ext)
  {
    // No previous, insert
    s_ext_targets.insert (l_tmp, new QVector< UmlArtifact > (16));
    l_ext = s_ext_targets.find (l_tmp);
    // CHECK (NULL != l_ext, "Could not find object after inserting!");
  }
  if (l_ext->size () == l_ext->count ())
  {
    l_ext->resize (l_ext->size () + 4);
  }
  l_ext->insert (l_ext->count (), &a_art);
}
else if (l_stereotype.contains (item_traits::document_stereotype, false))
{
  QCString l_tmp;
  if (l_name.contains (item_traits::buildfile_value, false))
  {
    // Is a template
    if (m_templates.count () == m_templates.size ())
    {
      m_templates.resize (m_templates.count () + 8);
    }
    m_templates.insert (m_templates.count (), &a_art);
#ifdef BUTTER_TRACE
    UmlCom::trace ("<p>Added template :" + l_name + " to location: " + path () + "</p>");
#endif
  }
  else
  {
    // Is a generic document
    if (m_documents.count () == m_documents.size ())
    {
      m_documents.resize (m_documents.count () + 8);
    }
    m_documents.insert (m_documents.count (), &a_art);
#ifdef BUTTER_TRACE
    UmlCom::trace ("<p>Added document :" + l_name + " to location: " + path () + "</p>");
#endif
  }
}
else if (l_stereotype.contains (item_traits::executable_stereotype, false))
{
  // Is a target
  if (m_targets.count () == m_targets.size ())
  {
    m_targets.resize (m_targets.count () + 8);
  }
  m_targets.insert (m_targets.count (), &a_art);
}
else if (l_stereotype.contains (item_traits::library_stereotype, false))
{
  // Is a target
  if (m_targets.count () == m_targets.size ())
  {
    m_targets.resize (m_targets.count () + 8);
  }
  m_targets.insert (m_targets.count (), &a_art);
}
!!!143145.cpp!!!	add_package(inout a_package : UmlPackage) : void
if (m_packages.count () == m_packages.size ())
{
  m_packages.resize (m_packages.count () + 8);
}
m_packages.insert (m_packages.count (), &a_package);

!!!164521.cpp!!!	create_document(in a_name : string) : UmlArtifact
BUTTER_REQUIRE (not has_document (a_name), "Cannot create a document with the name of an existing document.");
BUTTER_REQUIRE (not m_packages.isEmpty (), "Location has no packages!");
// Find deployment view
UmlDeploymentView * l_deploy (NULL);
for (unsigned int l_i (0); l_i < m_packages.count (); ++l_i)
{
  BUTTER_CHECK (NULL != m_packages.at (l_i), "Found a nul package.");
  const QVector< UmlItem > l_kids (m_packages.at (l_i)->children ());
  if (not l_kids.isEmpty ())
  {
    for (unsigned int l_j (0); l_j < l_kids.count (); ++l_j)
    {
      BUTTER_CHECK (NULL != l_kids.at (l_j), "nul child item found.");
      if (aDeploymentView == l_kids.at (l_j)->kind ())
      {
        l_deploy = dynamic_cast< UmlDeploymentView * > (l_kids.at (l_j));
        BUTTER_CHECK (NULL != l_deploy, "Item kind (DeploymentView) did not match class type");
        break;
      }
    }
  }
}
if (NULL == l_deploy)
{
  // Didn't find deployment view, add to first package.
  l_deploy = UmlDeploymentView::create (m_packages.at (0), m_packages.at (0)->name ());
  // QUERY = fails if create returns nul other than when non-package passed. 
  BUTTER_CHECK (NULL != l_deploy, "Unable to create a new deployment view.");
}
UmlArtifact * Result = UmlArtifact::create (l_deploy, a_name);
// QUERY = fails if create returns nul other than when non-deployment passed. 
BUTTER_CHECK (NULL != Result, "Unable to create a new artifact.");
Result->set_Stereotype (item_traits::document_stereotype);
// Add to document set
if (m_documents.count () == m_documents.size ())
{
  m_documents.resize (m_documents.count () + 8);
}
m_documents.insert (m_documents.count (), Result);
UmlCom::trace ("<p>New " + a_name + " document created.</p>");
return Result;
!!!138793.cpp!!!	find_create(in a_path : path) : location
location *Result (this);
// Build stack of dir steps
QStringList l_leaf;
#ifdef BUTTER_TRACE
UmlCom::trace ("<p>Search for location: " + a_path.path () + "</p>\n<p>search: .");
#endif
QDir l_path (m_path);
while (l_path != a_path)
{
  l_leaf.append (a_path.dirName ());
  a_path.cdUp ();
  BUTTER_ALWAYS (not a_path.isRoot (), "The path of a package is not a descendent of the project root.");
}
// Search up dir for existing locations
while (l_leaf.last ())
{
  location *l_old (Result);
  for (unsigned int l_i(0); l_i < Result->m_children.count (); ++l_i)
  {
    BUTTER_CHECK (NULL != Result->m_children.at (l_i), "nul child found.");
    if (QString(Result->m_children.at (l_i)->m_path) == l_leaf.last ())
    {
      Result = Result->m_children.at (l_i);
#ifdef BUTTER_TRACE
      UmlCom::trace ("/" + l_leaf.last ());
#endif
      break;
    }
  }
  if (l_old == Result)
  {
    // Could not find the next object, exit
    break;
  }
  l_leaf.remove (l_leaf.fromLast ());
}
#ifdef BUTTER_TRACE
UmlCom::trace (" | create:");
#endif
// Create any missing locations
while (l_leaf.last ())
{
  if (Result->m_children.size () == Result->m_children.count ())
  {
    Result->m_children.resize (Result->m_children.size () + 4);
  }
  Result->m_children.insert (Result->m_children.count (), new location (QCString(l_leaf.last ()), *Result));
  Result = Result->m_children.at (Result->m_children.count () - 1);
  BUTTER_CHECK (NULL != Result, "child nul after creation.");
#ifdef BUTTER_TRACE
  UmlCom::trace ("/" + l_leaf.last ());
#endif
  l_leaf.remove (l_leaf.fromLast ());
}
#ifdef BUTTER_TRACE
  UmlCom::trace ("</p>");
#endif

return Result;
!!!164393.cpp!!!	has_document(in a_name : string) : bool
BUTTER_REQUIRE (not a_name.isEmpty (), "Cannot look for a document without a name");  
bool Result (false);
// Only check in the document list.
for (unsigned int l_i (0); not Result and l_i < m_documents.count (); ++l_i)
{
  BUTTER_CHECK (NULL != m_documents.at (l_i), "Nul document found.");
  Result = (a_name == m_documents.at (l_i)->name () and item_traits::document_stereotype == m_documents.at (l_i)->stereotype ());
}
return Result;
!!!145833.cpp!!!	is_external_target(inout a_art : UmlArtifact) : bool
QCString l_tmp;
return const_cast< UmlArtifact& >(a_art).propertyValue (item_traits::butter_project_name, l_tmp);
!!!142633.cpp!!!	location(in a_path : path)
: m_children (16)
, m_documents (16)
, m_packages (16)
, m_parent (0)
, m_path (a_path.path ())
, m_targets (16)
, m_templates (16)
{}
!!!144425.cpp!!!	location(in a_path : string, inout a_parent : location)
: m_children (16)
, m_documents (16)
, m_packages (16)
, m_parent (&a_parent)
, m_path (a_path)
, m_targets (16)
, m_templates (16)
{}
!!!142761.cpp!!!	~location()
if (not m_children.isEmpty ())
{
  for (int l_i (0); l_i < m_children.count (); ++l_i)
  {
    delete m_children[l_i];
  }
}
!!!145705.cpp!!!	prune() : bool
// Return true if we have no targets or children (documents and
// templates are not considered).
if (not m_children.isEmpty ())
{
  unsigned int l_newsize (m_children.count ());
  for (unsigned int l_i (0); l_i < l_newsize;)
  {
    location *l_item (m_children.at (l_i));
    if (l_item->prune ())
    {
      // Child can not be pruned
      ++l_i;
    }
    else
    {
      // Child can be pruned (remove and swap last ptr to here), do not increment l_i
#ifdef BUTTER_TRACE
      UmlCom::trace ("<p>Removing directory with no targets: " + m_children.at (l_i)->path () + "</p>");
#endif
      m_children.remove (l_i);
      if (l_newsize - 1 > l_i)
      {
        m_children.insert (l_i, m_children.take (l_newsize - 1));
      }
      --l_newsize;
    }
  }
}
return not m_children.isEmpty () or not m_targets.isEmpty ();
!!!146601.cpp!!!	serialize(inout a_os : ostream) : void
a_os << "<<BEGIN build file [" << full_path () << "]\n";
if (m_documents.count () > 0)
{
  a_os << "Documents:\n";
  for (unsigned int l_i(0); l_i < m_documents.count (); ++l_i)
  {
    a_os << "[" << l_i << "] = " << m_documents.at (l_i)->name () << "\n";
  }
}
if (m_packages.count () > 0)
{
  a_os << "Packages:\n";
  for (unsigned int l_i(0); l_i < m_packages.count (); ++l_i)
  {
    a_os << "[" << l_i << "] = " << m_packages.at (l_i)->name () << "\n";
  }
}
if (m_targets.count () > 0)
{
  a_os << "Targets:\n";
  for (unsigned int l_i(0); l_i < m_targets.count (); ++l_i)
  {
    a_os << "[" << l_i << "] = " << m_targets.at (l_i)->name () << "\n";
  }
}
if (m_templates.count () > 0)
{
  a_os << "Templates:\n";
  for (unsigned int l_i(0); l_i < m_templates.count (); ++l_i)
  {
    a_os << "[" << l_i << "] = " << m_templates.at (l_i)->name () << "\n";
  }
}
if (m_children.count () > 0)
{
  a_os << "Children:\n";
  for (unsigned int l_i(0); l_i < m_children.count (); ++l_i)
  {
    a_os << "[" << l_i << "] = " << m_children.at (l_i)->path () << "\n";
  }
}
a_os << "<<END build file [" << full_path () << "]\n";

// Perform serialization in a top-down manner.
if (m_children.count () > 0)
{
  for (unsigned int l_i(0); l_i < m_children.count (); ++l_i)
  {
    m_children.at (l_i)->serialize (a_os);
  }
}

