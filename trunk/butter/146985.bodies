class build_writer
!!!200233.cpp!!!	find_hdr_link(in a_artifact : UmlArtifact, inout a_hdr : unistr, inout a_link : unistr, inout a_flag : unistr) : void
// Process any data from properties.
QString value_;
if (item_traits::property_value (a_artifact, item_traits::butter_flags_name, value_))
{
  if (not a_flag.isEmpty ()) { a_flag.append (" "); }
  a_flag.append (value_);
}
if (item_traits::property_value (a_artifact, item_traits::butter_ldflags_name, value_))
{
  if (not a_link.isEmpty ()) { a_link.append (" "); }
  a_link.append (value_);
}
if (item_traits::property_value (a_artifact, item_traits::butter_include_name, value_))
{
  if (not a_hdr.isEmpty ()) { a_hdr.append (" "); }
  a_hdr.append (value_);
}
// Process any data from the description.
QString section_ (section (item_traits::generic_section, const_cast< UmlArtifact& >(a_artifact).description ()));
if (not section_.isEmpty ())
{
  QRegExp l_hdr_re ("^ *" + item_traits::header_label + " *= *");
  QRegExp l_link_re ("^ *" + item_traits::link_label + " *= *");
  QRegExp l_flag_re ("^ *" + item_traits::flag_label + " *= *");
  if (not section_.isEmpty ())
  {
    QTextIStream section__is (&section_);
    while (not section__is.atEnd ())
    {
      const QString l_line (section__is.readLine ());
      int l_length;
      if (-1 != l_hdr_re.match (l_line, 0, &l_length))
      {
        if (not a_hdr.isEmpty ()) { a_hdr.append (" "); }
        a_hdr.append (l_line.mid (l_length));
      }
      else if (-1 != l_link_re.match (l_line, 0, &l_length))
      {
        if (not a_link.isEmpty ()) { a_link.append (" "); }
        a_link.append (l_line.mid (l_length));
      }
      else if (-1 != l_flag_re.match (l_line, 0, &l_length))
      {
        if (not a_flag.isEmpty ()) { a_flag.append (" "); }
        a_flag.append (l_line.mid (l_length));
      }
    }
  }
}
!!!194089.cpp!!!	get_artifact(inout a_loc : location, in a_name : unistr) : compound_artifact
// Get deployment views from current location's packages
std::auto_ptr< compound_artifact > Result;
if (a_loc.packages ().count () > 0)
{
  QPtrVector< UmlItem > docs_ = a_loc.find_uml_document (a_name);
  // If any documents found
  if (not docs_.isEmpty ())
  {
    Result.reset (new compound_artifact (dynamic_cast< UmlArtifact& >(*docs_.at (0))));
    for (unsigned int k_ = 1; k_ < docs_.count (); ++k_)
    {
      UmlItem * item_ = docs_.at (k_);
      Result->merge (dynamic_cast< UmlArtifact& >(*item_));
      log::com.trace (log::info, "<p><b>Note:</b> Removing duplicated build file from Package " + item_->parent ()->name () + "</p>\n");
      // item_->parent ()->children ().remove (item_->parent ()->children ().findRef (item_));
      item_->set_Name (("OLD_" + a_name).utf8 ());
    }
    // Reset the artifact (keeps section labels but empties content)
    Result->reset ();
  }
}
if (NULL == Result.get ())
{
  // This will throw an error if no packages exist.
  Result.reset (new compound_artifact (*a_loc.create_uml_document (a_name)));
}
return Result;
!!!192425.cpp!!!	section(in a_section : unistr, in a_desc : unistr) : unistr
static const QString l_START ("${" + item_traits::section_prefix);
const QString l_phrase (l_START + a_section + "}");
QString Result;
int l_start (a_desc.find (l_phrase));
if (-1 != l_start)
{
  // Found a_section start, search from here to end for next section
  int l_end (a_desc.find (l_START, l_start + l_phrase.length ()));
  if (-1 != l_end)
  {
    Result = a_desc.mid (l_start + l_phrase.length (), l_end - (l_start + l_phrase.length ()));
  }
  else
  {
    Result = a_desc.mid (l_start + l_phrase.length ());
  }
}
else if (-1 == a_desc.find (l_START))
{
  // Found no section titles, use all of desc
  Result = a_desc;
}
return Result;
