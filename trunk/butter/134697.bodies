class jam_writer
!!!158121.cpp!!!	descendent_link(inout a_art : compound_artifact, inout a_sys : compound_artifact, in a_loc : location) : void
// Need to write the TOP line.
if (NULL != a_loc.parent ())
{
  // Build SubDir.
  const location *loc_cursor_ = &a_loc;
  QString dir_line_;
  while (NULL != loc_cursor_->parent ())
  {
    dir_line_.insert (0, loc_cursor_->path ());
    dir_line_.insert (0, " ");
    loc_cursor_ = loc_cursor_->parent ();
  }
  QString subdir_line_ ("SubDir TOP" + dir_line_ + " ;\n\n");
  // Insert the subdir flags into l_buffer. 
  if (not m_flags.isEmpty ())
  {
    subdir_line_.append ("\nSUBDIRC++FLAGS += " + m_flags + " ;\n");
    m_flags.truncate (0);
  }
  if (not m_headers.isEmpty ())
  {
    subdir_line_.append ("\nSUBDIRHDRS += " + m_headers + " ;\n");
    m_headers.truncate (0);
  }

  a_art.preamble.second.insert (0, subdir_line_);
  // Add definition to top-level
  if (not dir_line_.isEmpty ())
  {
    // Find out project
    a_sys.target (dir_line_).second = ("SubInclude TOP" + dir_line_ + " ;\n\n");
  }
}
!!!156329.cpp!!!	initialise(inout a_base : location, in a_project : UmlItem, inout a_sys : compound_artifact) : void
BUTTER_REQUIRE (NULL == a_base.parent (), "initialise can only be called on the top-most location");
QString content_;
QTextOStream os_ (&content_);
// The include dir is the difference between the current fullpath and the
// top-projects hdrDir
os_ << "SubDir TOP ;\n";
const QString base_path_ (a_base.full_path ());
QString requirement_text_;
if (requirements (a_project, requirement_text_))
{
  os_ << requirement_text_;
}

QString toplevel_include_ (item_traits::hdrname (dynamic_cast< const UmlPackage& >(a_project)).path ());
if (not toplevel_include_.isEmpty () and toplevel_include_ != base_path_)
{
  if (0 == toplevel_include_.find (base_path_))
  {
    os_ << "HDRS += \"" << toplevel_include_.mid (base_path_.length () + 1) << "\" ;\n\n";
  }
  else
  {
    os_ << "HDRS += \"" << toplevel_include_ << "\" ;\n\n";
  }
}
a_sys.preamble.second = content_;
!!!174377.cpp!!!	install_target(in a_target_name : unistr, in a_loc_var : unistr, inout a_os : ostream, in a_install_type : uint = generic) : void
if (a_loc_var != item_traits::no_install_value)
{
  static const char * l_install_cmd[] =
  {
    "InstallBin"
  , "InstallFile"
  , "InstallInto"
  , "InstallLib"
  , "InstallMan"
  };
  a_os << l_install_cmd [a_install_type] << " $("  << a_loc_var;
  a_os << ") : " << a_target_name << " ;\n";
}
!!!156201.cpp!!!	local_target(in a_current : location, in a_target : UmlArtifact, inout a_localdoc : compound_artifact) : void
#line 300
QPtrVector < UmlArtifact > assoc_arts_ (const_cast< UmlArtifact& >(a_target).associatedArtifacts ());
if (not assoc_arts_.isEmpty ())
{
  bool Result (true);
  QString tmp_;
  QTextOStream os_ (&tmp_);
  QString source_extras_;
  QTextOStream source_os_ (&source_extras_);
  // a_target must be execution or library stereotype
  QString here_ ("<" + item_traits::location (a_target) + ">");
  QString lib_stat_or_shar_;
  QString install_dir_;
  unsigned int install_type_ (generic);
  const QString target_stereo_ (const_cast< UmlArtifact& >(a_target).stereotype ().data ());
  if (target_stereo_ == item_traits::library_stereotype)
  {
    QString other_target_type_;
    install_type_ = lib;
    if (item_traits::property_value (a_target, item_traits::butter_other_name, other_target_type_))
    {
      os_ << other_target_type_ << " ";
    }
    else
    {
      here_.append ("lib" + const_cast< UmlArtifact& >(a_target).name () + "$(SUFLIB)");
      os_ << "Library " << here_  << " :\n\t";
    }
    if (not item_traits::property_search (a_target, item_traits::butter_lib_type_name, lib_stat_or_shar_))
    {
      lib_stat_or_shar_ = item_traits::static_value;
    }
    if (not item_traits::property_value (a_target, item_traits::butter_install_name, install_dir_))
    {
      install_dir_ = item_traits::libdir_value;
    }
    else
    {
      if (install_dir_ != item_traits::libdir_value)
      {
        install_type_ = generic; // Reset to generic.
      }
    }
  }
  else if (target_stereo_ == item_traits::executable_stereotype)
  {
    install_type_ = bin;
    here_.append (const_cast< UmlArtifact& >(a_target).name () + "$(SUFEXE)");
    os_ << "Main " << here_ << " :\n\t";
    if (not item_traits::property_value (a_target, item_traits::butter_install_name, install_dir_))
    {
      install_dir_ = item_traits::bindir_value;
    }
    else
    {
      if (install_dir_ != item_traits::bindir_value)
      {
        install_type_ = generic; // Reset to generic.
      }
    }
  }
  else
  {
    Result = false;
  }
  if (Result) // Only continue if we have a local target.
  {
    QString lib_defn_;
    QTextOStream lib_defn_os_ (&lib_defn_);
    QString link_flags_;
    QString includes_;
    QString cflags_;
    find_hdr_link (a_target, includes_, link_flags_, cflags_);
    for (unsigned int i_ (0); i_ < assoc_arts_.size (); ++i_)
    {
      UmlArtifact *const current_art_ (assoc_arts_.at (i_));
      const QString stereotype_ (current_art_->stereotype ().data ());
      if (stereotype_ == item_traits::library_stereotype)
      {
        QString l_linker;
        if (item_traits::property_value (*current_art_, item_traits::butter_project_name, l_linker))
        {
          // Is an externally linked library, look for HDR and LINKLIB lines.
          find_hdr_link (*current_art_, includes_, link_flags_, cflags_);
        }
        else
        {
          lib_defn_os_ << "<" << item_traits::location (*current_art_) << ">lib" << current_art_->name () << "$(SUFLIB)\n\t";
        }
      }
      else if (stereotype_ == item_traits::source_stereotype)
      {
        QString src_inc_, src_flags_;
        find_hdr_link (*current_art_, src_inc_, link_flags_, src_flags_); // Pass link flags to target
        if (not src_inc_.isEmpty ())
        {
          source_os_ << "HDR on <" << item_traits::location (*current_art_) << ">"
                     << current_art_->name () << "$(SUFOBJ) += " << src_inc_ << " ;\n";
        }
        if (not src_flags_.isEmpty ())
        {
          source_os_ << "C++FLAGS on <" << item_traits::location (*current_art_) << ">"
                     << current_art_->name () << "$(SUFOBJ) += " << src_flags_ << " ;\n";
        }
        os_ << "<" << item_traits::location (*current_art_) << ">" << current_art_->name () << "." << CppSettings::sourceExtension () << "\n\t";
      }
      else if (stereotype_ == item_traits::document_stereotype)
      {
        QString src_inc_, src_flags_;
        find_hdr_link (*current_art_, src_inc_, link_flags_, src_flags_); // Pass link flags to target
        if (not src_inc_.isEmpty ())
        {
          const int dot_ (current_art_->name ().findRev ('.'));
          source_os_ << "HDR on <" << item_traits::location (*current_art_) << ">";
          if (-1 == dot_)
            source_os_ << current_art_->name () << "$(SUFOBJ) += " << src_inc_ << " ;\n";
          else
            source_os_ << current_art_->name ().left (dot_ - 1) << "$(SUFOBJ) += " << src_inc_ << " ;\n";
        }
        if (not src_flags_.isEmpty ())
        {
          QString comp_;
          BUTTER_ALWAYS(item_traits::property_value (*current_art_, item_traits::butter_compiler_name, comp_)
                        , std::string (("<p><b>Error:</b> Missing '" + item_traits::butter_compiler_name
                                       + "' property on " + QString (current_art_->name ())).ascii ()));
          const int dot_ (current_art_->name ().findRev ('.'));
          source_os_ << comp_ << "FLAGS on <" << item_traits::location (*current_art_) << ">";
          if (-1 == dot_)
            source_os_ << current_art_->name () << "$(SUFOBJ) += " << src_flags_ << " ;\n\t";
          else
            source_os_ << current_art_->name ().left (dot_ - 1) << "$(SUFOBJ) += " << src_flags_ << " ;\n\t";
        }
        os_ << "<" << item_traits::location (*current_art_) << ">" << current_art_->name () << "\n\t";
      }
    }
    os_ << ";\n\n";

    if (not lib_defn_.isEmpty ())
    {
      os_ << "LinkLibraries " << here_ << " :\n\t" << lib_defn_ << ";\n\n";
    }
    if (not includes_.isEmpty ())
    {
      merge_headers (includes_);
    }
    if (not cflags_.isEmpty ())
    {
      merge_flags (cflags_);
    }
    if (not link_flags_.isEmpty ())
    {
      os_ << "LINKLIBS on " << here_ << " += " << link_flags_ << " ;\n\n";
    }

//    if (not lib_stat_or_shar_.isEmpty ())
//    {
//      os_ << "<link>" << lib_stat_or_shar_ << "\n\t";
//    }
//    QString current_art_;
//    if (requirements (a_target, current_art_))
//    {
//      os_ << current_art_;
//    }
//    os_ << ";\n\n";
    if (not install_dir_.isEmpty ())
    {
      install_target (here_, install_dir_, os_, install_type_);
    }
    if (not source_extras_.isEmpty ())
    {
      source_os_ << "\n" << tmp_;
      a_localdoc.target (const_cast< UmlArtifact& >(a_target).name ()).second = source_extras_;
    }
    else
    {
      a_localdoc.target (const_cast< UmlArtifact& >(a_target).name ()).second = tmp_;
    }
  }
}
!!!176681.cpp!!!	merge_string_list(inout a_list : unistr, in a_addition : unistr) : void
if (a_list.isEmpty ())
{
  a_list = a_addition;
}
else if (not a_list.contains (a_addition))
{
  // a_addition is not a subset of a_list
  if (a_addition.contains (a_list))
  {
    // a_list is a subset of a_addition, swap.
    a_list = a_addition;
  }
  else
  {
    // contents do not overlap, split and compare
    QRegExp l_splitter ("(\\S*\"[^\"]+\"\\S*|\\S+)");
    QStringList l_list1 (QStringList::split (l_splitter, a_list, false));
    QStringList l_list2 (QStringList::split (l_splitter, a_addition, false));
    int l_counter (0); // Guard counter.
    for (QStringList::Iterator l_cursor = l_list2.begin(); l_cursor != l_list2.end(); ++l_cursor,  ++l_counter)
    {
      if (0 == l_list1.contains (*l_cursor))
      {
         l_list1 += *l_cursor;
      }
      if (l_counter >= 100) throw "merge_string_list loop counter > 100";
    }
    a_list = l_list1.join (" ");
  }
}
!!!155817.cpp!!!	requirements(in a_item : UmlItem, inout a_reqs : unistr) : bool
bool Result (false);
QString l_tmp;
QString l_section;
QTextOStream l_os (&l_section);
if (item_traits::property_value (a_item, item_traits::butter_include_name, l_tmp))
{
  Result = true;
  l_os << "HDRS += ";
  QStringList l_list (QStringList::split (" ", l_tmp));
  for (unsigned int l_i (0); l_i < l_list.count (); ++l_i)
  {
    l_os << "\"" << (*l_list.at (l_i)).stripWhiteSpace () << "\" ";
  }
  l_os << ";\n";
}
if (item_traits::property_search (a_item, item_traits::butter_ldflags_name, l_tmp))
{
  Result = true;
  l_os << "LINKLIBS += \"" << l_tmp << "\" ;\n";
}
if (item_traits::property_search (a_item, item_traits::butter_flags_name, l_tmp))
{
  Result = true;
  l_os << "C++FLAGS += \"" << l_tmp << "\" ;\n";
}
if (Result)
{
  a_reqs = l_section;
}
return Result;
