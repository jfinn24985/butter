class jam_writer
!!!158121.cpp!!!	descendent_link(inout a_art : compound_artifact, in a_loc : location) : void
// Need to write the TOP line.
if (NULL != a_loc.parent ())
{
  // Build SubDir.
  const location *loc_cursor_ = &a_loc;
  QString dir_line_;
  while (NULL != loc_cursor_->parent ())
  {
    dir_line_.insert (0, loc_cursor_->path ());
    dir_line_.insert (0, " ");
    loc_cursor_ = loc_cursor_->parent ();
  }
  QString subdir_line_ ("SubDir TOP" + dir_line_ + " ;\n\n");
  // Insert the subdir flags into l_buffer. 
  if (not m_flags.isEmpty ())
  {
    subdir_line_.append ("\nSUBDIRC++FLAGS += " + m_flags + " ;\n");
    m_flags.resize (0);
  }
  if (not m_headers.isEmpty ())
  {
    subdir_line_.append ("\nSUBDIRHDRS += " + m_headers + " ;\n");
    m_headers.resize (0);
  }

  a_art.preamble.second.insert (0, subdir_line_);
  // Add definition to top-level
  if (not dir_line_.isEmpty ())
  {
    system_artifact_->close.second.append ("SubInclude TOP" + dir_line_ + " ;\n\n");
  }
}
!!!156329.cpp!!!	initialise(inout a_base : location, in a_project : UmlItem) : void
BUTTER_REQUIRE (NULL == a_base.parent (), "initialise can only be called on the top-most location");
QString content_;
QTextOStream os_ (&content_);
// The include dir is the difference between the current fullpath and the
// top-projects hdrDir
os_ << "SubDir TOP ;\n";
const QCString base_path_ (a_base.full_path ());
QCString requirement_text_;
if (requirements (a_project, requirement_text_))
{
  os_ << requirement_text_;
}

QCString toplevel_include_ (item_traits::hdrname (dynamic_cast< const UmlPackage& >(a_project)).path ());
if (not toplevel_include_.isEmpty () and toplevel_include_ != base_path_)
{
  if (0 == toplevel_include_.find (base_path_))
  {
    os_ << "HDRS += \"" << toplevel_include_.mid (base_path_.length () + 1) << "\" ;\n\n";
  }
  else
  {
    os_ << "HDRS += \"" << toplevel_include_ << "\" ;\n\n";
  }
}
system_artifact_->preamble.second = content_;

// If no makefile docs...
if (a_base.find_uml_document (s_rules_name).isEmpty ())
{
  QCString l_ver;
  if (not const_cast< UmlItem & > (a_project).propertyValue (item_traits::butter_version_name, l_ver))
  {
    if (not const_cast< UmlItem & > (a_project).propertyValue (item_traits::version_name, l_ver))
    {
      l_ver = "1.0";
    }
  }
  QCString l_default_rules (s_default_rules);
  int l_i (0);
  const QCString l_project ("@@project@@");
  const QCString l_version ("@@version@@");
  if (-1 != (l_i = l_default_rules.find (l_project)))
  {
    l_default_rules.replace (l_i, l_project.length (), const_cast< UmlItem & > (a_project).name ());
  }
  if (-1 != (l_i = l_default_rules.find (l_version)))
  {
    l_default_rules.replace (l_i, l_version.length (), l_ver);
  };
  a_base.create_uml_document (s_rules_name)->set_Description (l_default_rules);
}
!!!174377.cpp!!!	install_target(in a_target_name : string, in a_loc_var : string, inout a_os : ostream, in a_install_type : uint = generic) : void
if (a_loc_var != item_traits::no_install_value)
{
  static const char * l_install_cmd[] =
  {
    "InstallBin"
  , "InstallFile"
  , "InstallInto"
  , "InstallLib"
  , "InstallMan"
  };
  a_os << l_install_cmd [a_install_type] << " $("  << a_loc_var;
  a_os << ") : " << a_target_name << " ;\n";
}
!!!156201.cpp!!!	local_target(in a_current : location, in a_target : UmlArtifact, inout a_localdoc : compound_artifact) : void
#line 300
QPtrVector < UmlArtifact > assoc_arts_ (const_cast< UmlArtifact& >(a_target).associatedArtifacts ());
if (not assoc_arts_.isEmpty ())
{
  bool Result (true);
  QString tmp_;
  QTextOStream os_ (&tmp_);
  // a_target must be execution or library stereotype
  QCString here_ ("<" + item_traits::location (a_target) + ">");
  QCString lib_stat_or_shar_;
  QCString install_dir_;
  unsigned int install_type_ (generic);
  if (const_cast< UmlArtifact& >(a_target).stereotype () == item_traits::library_stereotype)
  {
    QCString other_target_type_;
    install_type_ = lib;
    if (const_cast< UmlArtifact& >(a_target).propertyValue (item_traits::butter_other_name, other_target_type_))
    {
      os_ << other_target_type_ << " ";
    }
    else
    {
      here_.append ("lib" + const_cast< UmlArtifact& >(a_target).name () + "$(SUFLIB)");
      os_ << "Library " << here_  << " :\n\t";
    }
    if (not item_traits::property_search (a_target, item_traits::butter_lib_type_name, lib_stat_or_shar_))
    {
      lib_stat_or_shar_ = item_traits::static_value;
    }
    if (not const_cast< UmlArtifact& >(a_target).propertyValue (item_traits::butter_install_name, install_dir_))
    {
      install_dir_ = item_traits::libdir_value;
    }
    else
    {
      if (install_dir_ != item_traits::libdir_value)
      {
        install_type_ = generic; // Reset to generic.
      }
    }
  }
  else if (const_cast< UmlArtifact& >(a_target).stereotype () == item_traits::executable_stereotype)
  {
    install_type_ = bin;
    here_.append (const_cast< UmlArtifact& >(a_target).name () + "$(SUFEXE)");
    os_ << "Main " << here_ << " :\n\t";
    if (not const_cast< UmlArtifact& >(a_target).propertyValue (item_traits::butter_install_name, install_dir_))
    {
      install_dir_ = item_traits::bindir_value;
    }
    else
    {
      if (install_dir_ != item_traits::bindir_value)
      {
        install_type_ = generic; // Reset to generic.
      }
    }
  }
  else
  {
    Result = false;
  }
  if (Result) // Only continue if we have a local target.
  {
    QString lib_defn_;
    QTextOStream lib_defn_os_ (&lib_defn_);
    QCString link_flags_;
    QCString includes_;
    QCString cflags_;
    for (unsigned int i_ (0); i_ < assoc_arts_.size (); ++i_)
    {
      UmlArtifact *const current_art_ (assoc_arts_.at (i_));
      if (current_art_->stereotype () == item_traits::library_stereotype)
      {
        QCString l_linker;
        if (current_art_->propertyValue (item_traits::butter_project_name, l_linker))
        {
          // Is an externally linked library, look for HDR and LINKLIB lines.
          find_hdr_link (current_art_->description (), includes_, link_flags_, cflags_);
        }
        else
        {
          lib_defn_os_ << "<" << item_traits::location (*current_art_) << ">lib" << current_art_->name () << "$(SUFLIB)\n\t";
        }
      }
      else if (current_art_->stereotype () == item_traits::source_stereotype)
      {
        os_ << "<" << item_traits::location (*current_art_) << ">" << current_art_->name () << "." << CppSettings::sourceExtension () << "\n\t";
      }
    }
    os_ << ";\n\n";

    if (not lib_defn_.isEmpty ())
    {
      os_ << "LinkLibraries " << here_ << " :\n\t" << lib_defn_ << ";\n\n";
    }
    if (not includes_.isEmpty ())
    {
      merge_headers (includes_);
    }
    if (not cflags_.isEmpty ())
    {
      merge_flags (cflags_);
    }
    if (not link_flags_.isEmpty ())
    {
      os_ << "LINKLIBS on " << here_ << " += " << link_flags_ << " ;\n\n";
    }

//    if (not lib_stat_or_shar_.isEmpty ())
//    {
//      os_ << "<link>" << lib_stat_or_shar_ << "\n\t";
//    }
//    QCString current_art_;
//    if (requirements (a_target, current_art_))
//    {
//      os_ << current_art_;
//    }
//    os_ << ";\n\n";
    if (not install_dir_.isEmpty ())
    {
      install_target (here_, install_dir_, os_, install_type_);
    }
    a_localdoc.target (const_cast< UmlArtifact& >(a_target).name ()).second = tmp_;
  }
}
!!!176681.cpp!!!	merge_string_list(inout a_list : string, in a_addition : string) : void
if (a_list.isEmpty ())
{
  a_list = a_addition;
}
else if (not a_list.contains (a_addition))
{
  // a_addition is not a subset of a_list
  if (a_addition.contains (a_list))
  {
    // a_list is a subset of a_addition, swap.
    a_list = a_addition;
  }
  else
  {
    // contents do not overlap, split and compare
    QRegExp l_splitter ("(\\S*\"[^\"]+\"\\S*|\\S+)");
    QStringList l_list1 (QStringList::split (l_splitter, a_list, false));
    QStringList l_list2 (QStringList::split (l_splitter, a_addition, false));
    int l_counter (0); // Guard counter.
    for (QStringList::Iterator l_cursor = l_list2.begin(); l_cursor != l_list2.end(); ++l_cursor,  ++l_counter)
    {
      if (0 == l_list1.contains (*l_cursor))
      {
         l_list1 += *l_cursor;
      }
      if (l_counter >= 100) throw "merge_string_list loop counter > 100";
    }
    a_list = l_list1.join (" ");
  }
}
!!!155817.cpp!!!	requirements(in a_item : UmlItem, inout a_reqs : string) : bool
bool Result (false);
QCString l_tmp;
QString l_section;
QTextOStream l_os (&l_section);
if (const_cast< UmlItem& >(a_item).propertyValue (item_traits::butter_include_name, l_tmp))
{
  Result = true;
  l_os << "HDRS += ";
  QStringList l_list (QStringList::split (" ", l_tmp));
  for (unsigned int l_i (0); l_i < l_list.count (); ++l_i)
  {
    l_os << "\"" << (*l_list.at (l_i)).stripWhiteSpace () << "\" ";
  }
  l_os << ";\n";
}
if (item_traits::property_search (a_item, item_traits::butter_ldflags_name, l_tmp))
{
  Result = true;
  l_os << "LINKLIBS += \"" << l_tmp << "\" ;\n";
}
if (item_traits::property_search (a_item, item_traits::butter_flags_name, l_tmp))
{
  Result = true;
  l_os << "C++FLAGS += \"" << l_tmp << "\" ;\n";
}
if (Result)
{
  a_reqs = l_section;
}
return Result;
