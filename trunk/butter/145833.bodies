class pathcmp
!!!216361.cpp!!!	convert_separators(in a_trans : unistr) : unistr
return path ().replace (QRegExp (default_separator_), a_trans);
!!!186025.cpp!!!	create_common(in a_other : pathcmp) : unistr
const QString lhs_ = absPath ();
const QString rhs_ = a_other.absPath ();
const int sz1_ = lhs_.length ();
const int sz2_ = rhs_.length ();
const int sz_ = (sz1_ < sz2_) ? sz1_ : sz2_;
int last_sep_ = 0;
for (int c_ = 0; c_ < sz_; ++c_)
{
  if (default_separator_[0] == lhs_[c_])
  {
    last_sep_ = c_;
  }
  if (lhs_[c_] != rhs_[c_])
  {
    // End of common
    return (last_sep_ > 0)
    	? lhs_.left (last_sep_)
    	: QString ();
  }
}
// Matched all of smaller path.
return lhs_.left (sz_);
!!!186281.cpp!!!	create_relative(in a_target : pathcmp) : unistr
QString Result;
#ifndef NO_ARRAY_INITIALISER
const char sep_[4] = { '.', '.', default_separator_[0], '\0' };
#else
char sep_[4];
sep_[0] = '.';
sep_[1] = '.';
sep_[2] = default_separator_[0];
sep_[3] = '\0';
#endif
const QString path1_ = absPath ();
const QString path2_ = a_target.absPath ();
const int sz1_ (path1_.length ());
const int sz2_ (path2_.length ());
const int sz_ = (sz1_ < sz2_) ? sz1_ : sz2_;
// Determine the parent dirs in common.
int last_sep_ = 0;
for (int i_ = 0; true; ++i_)
{
  if (default_separator_[0] == path1_[i_])
  {
    last_sep_ = i_;
  }
  if (i_ >= sz_)
  { // End of shorter path
    last_sep_ = i_;
    break;
  }
  if (path1_[i_] != path2_[i_])
  { // End of common path
    break; 
  }
}
#ifdef _WS_WIN_
// Throw exception when the two directories are not on the same partition
if (0 == last_sep_)
{
  if (default_separator_[0] != path1_[last_sep_])
  {
    throw std::runtime_error (("<p><b>Configuration error</b> Path " 
                       + path1_ + " and " + path2_ + " are not on the same partition.").utf8().data ());
  }
}
#endif
// Append "up dirs" for each separator between last_sep_ and end.
for (int ii_ = path1_.right (sz1_ - last_sep_).contains (default_separator_[0]); ii_ > 0; --ii_)
{
  Result.append (&sep_[0]);
}
if (sz2_ > last_sep_)
{
  // Add down elements from common to a_target
  Result.append (path2_.right (sz2_ - last_sep_ - 1));
}
else
{
  // No down elements, remove trailing separator
  Result.truncate (Result.length () - 1);
}
return Result;
!!!185769.cpp!!!	equality(in a_rhs : pathcmp) : bool
const QString lhs_ = absPath ();
const QString rhs_ = a_rhs.absPath ();
// Do simple comparison first
if (lhs_ == rhs_)
{
  return true;
}
const unsigned int lhs_sz_ = lhs_.length ();
const unsigned int rhs_sz_ = rhs_.length ();
switch (lhs_sz_ - rhs_sz_)
{
// check if lhs_ ends in redundant separator
case 1:
{
  if (default_separator_[0] == lhs_[lhs_sz_ - 1])
  {
    return lhs_.startsWith (rhs_);
  }
  break;
}
// check if rhs_ ends in redundant separator
case -1:
{
  if (default_separator_[0] == rhs_[rhs_sz_ - 1])
  {
    return rhs_.startsWith (lhs_);
  }
  break;
}
default:
  break;
}
return false;
!!!185897.cpp!!!	has_subpath(in a_rhs : pathcmp) : bool
// simple test that a subdirs path string must have longer pathname
const QString lhs_ = absPath ();
const QString rhs_ = a_rhs.absPath ();
bool Result (lhs_.length () < rhs_.length ());
// Test if rhs_ begins with lhs_
if (Result)
{
  Result = rhs_.startsWith (lhs_);
}
return Result;
!!!185257.cpp!!!	leaf_at(in a_count : uint) : unistr
int s_ = 0, e_ = 0; // start, end counter
QString path_ (path ());
while (true)
{
  e_ = path_.find (default_separator_[0], s_);
  if (e_ < 0) // End of path string, check at last item
  {
    if (a_count != 0)
    {
      throw std::runtime_error ("Attempt to go beyond end of path.");
    }
    e_ = path_.length ();
  }
  if (a_count == 0)
  {
    return path_.mid (s_, e_ - s_);
  }
  s_ = e_ + 1;
  --a_count;
}
