class text_template
!!!287152.cpp!!!	read(inout xml : QXmlStreamReader) : void
BUTTER_REQUIRE(xml.isStartElement() && (xml.name() == text_template_xmlname()),
               ("XML reader not at a "+text_template_xmlname()+" element in call to text_template::read.").toStdString());
if(! this->sequence_.empty())
{
  this->sequence_.clear();
}
{
  int counter{ 0 };
  QVector< QString > phrases;
  while (!xml.atEnd())
  {
    ++counter;
    switch(xml.readNext())
    {
    case QXmlStreamReader::StartElement:
    {
      if(xml.name() == replacement_xmlname())
      {
        BUTTER_REQUIRE(xml.attributes().hasAttribute(label_xmlname()),
                       QString("Replacement XML element does not have required attribute at line %1").arg(xml.lineNumber()).toStdString() );
        // Add attribute nodes before replace nodes
        if(xml.attributes().hasAttribute("prefix"))
        {
          this->sequence_.push_back( { REPLACE_PREFIX, xml.attributes().value("prefix").toString() } );
        }
        if(xml.attributes().hasAttribute("suffix"))
        {
          this->sequence_.push_back( { REPLACE_SUFFIX, xml.attributes().value("suffix").toString() } );
        }
        if(xml.attributes().hasAttribute("join"))
        {
          this->sequence_.push_back( { REPLACE_JOIN, xml.attributes().value("join").toString() } );
        }
        if(xml.attributes().hasAttribute("split"))
        {
          this->sequence_.push_back( { REPLACE_SPLIT, xml.attributes().value("split").toString() } );
        }
        this->sequence_.push_back( { REPLACEMENT, xml.attributes().value(label_xmlname()).toString() } );
        if(QXmlStreamReader::EndElement != xml.readNext())
        {
          BUTTER_REQUIRE(false,
                        QString("Replacement XML element should be empty at line %1").arg(xml.lineNumber()).toStdString() );
        }
      }
      else if(xml.name() == optional_xmlname())
      {
        BUTTER_REQUIRE(xml.attributes().hasAttribute(label_xmlname()),
                       QString("Optional section XML element does not have required attribute at line %1").arg(xml.lineNumber()).toStdString() );
        QString content{ xml.attributes().value(label_xmlname()).toString()
           + QString::number( counter ) };
        if( ! xml.attributes().value(target_xmlname()).isEmpty() )
        {
          content += " " + xml.attributes().value(target_xmlname()).toString();
        }
        phrases.push_back( content );
        this->sequence_.push_back( { PHRASE, phrases.back() } );
      }
      else
      {
        BUTTER_REQUIRE(false, QString("Unexpected XML start element "+xml.name().toString()+" at line %1").arg(xml.lineNumber()).toStdString() );
      }
    }
    break;
    case QXmlStreamReader::EndElement:
    {
      if(xml.name() == replacement_xmlname())
      {
        BUTTER_REQUIRE(false,
                       QString("Misplaced end to replacement XML element at line %1").arg(xml.lineNumber()).toStdString() );
      }
      else if(xml.name() == text_template_xmlname())
      {
        // At end of this template
        BUTTER_REQUIRE(phrases.empty(), "Incorrectly nested optional sections.");
        return;
      }
      else if(xml.name() == optional_xmlname())
      {
        this->sequence_.push_back( { PHRASE, phrases.back() } );
        phrases.pop_back();
      }
      else
      {
        BUTTER_REQUIRE(false, QString("Unexpected XML end element "+xml.name().toString()+" at line %1").arg(xml.lineNumber()).toStdString() );
      }
    }
    break;
    case QXmlStreamReader::Characters:
    {
      this->sequence_.push_back( { TEXT, xml.text().toString() } );
    }
    break;
    case QXmlStreamReader::Comment:
      // Ignore
      break;
    case QXmlStreamReader::ProcessingInstruction:
      // Ignore
      break;
    default:
      // All others are errors!
      throw std::runtime_error( QString("Unexpected XML element '%1' in stream at line %2").arg(xml.name().toString(), QString("%1").arg(xml.lineNumber())).toStdString() );
      break;
    }
  }
  BUTTER_REQUIRE(phrases.empty(), "Incorrectly nested optional sections.");
}
!!!287280.cpp!!!	instantiate(in properties : text_template::map_type) : unistr
QVector< QString > result;
result.push_back(QString());
if(! this->sequence_.empty())
{
  QVector< QString > phrases;
  QVector< QStringList > discard_phrase;
  QString prefix, suffix, split, join;
  bool has_split{ false }, has_join{ false }; // if split/join called with empty strings
  QTextOStream os(&result.back());
  for( const template_entry & entry : this->sequence_ )
  {
    switch(entry.type_)
    {
    case entry_type::TEXT:
      os << entry.content_;
      break;
    case entry_type::REPLACE_PREFIX:
      prefix = entry.content_;
      break;
    case entry_type::REPLACE_SUFFIX:
      suffix = entry.content_;
      break;
    case entry_type::REPLACE_JOIN:
      join = entry.content_;
      has_join = true;
      break;
    case entry_type::REPLACE_SPLIT:
      split = entry.content_;
      has_split = true;
      break;
    case entry_type::REPLACEMENT:
    {
      auto itr{ properties.find(entry.content_) };
      if( itr != properties.end() )
      {
        if(! discard_phrase.empty()) // in phrase, indicate value found
        {
          discard_phrase.back().push_back(entry.content_);
        }
        QString value = itr.value();
        if( has_split || has_join )
        {
          value = value.split( has_split ? split : " " ).join( has_join ? join : " " );
        }
        if( ! prefix.isEmpty() ) os << prefix;
        os << value;
        if( ! suffix.isEmpty() ) os << suffix;
      }
      prefix.clear(); suffix.clear(); split.clear(); join.clear();
      has_split = has_join = false;
    }
    break;
    case entry_type::PHRASE:
    {
      if(! phrases.empty() and phrases.back() == entry.content_)
      {
        // end of optional section
        os.flush();
        QString tmp{ result.back() };
        result.pop_back();
        os.setString(&result.back());
        QStringList required_replacements{ entry.content_.split(' ')};
        if(required_replacements.count() > 1)
        {
          // all only if specific replacements made
          bool has_missing_replacement = false;
          required_replacements.pop_front();
          for( auto & s : required_replacements )
          {
            has_missing_replacement = ! discard_phrase.back().contains(s);
            if( has_missing_replacement ) break;
          } 
          if( ! has_missing_replacement )
          {
            os << tmp;
          }
        }
        else
        {
          // allow if any replacements made
          if(! discard_phrase.back().isEmpty())
          {
            os << tmp;
          }
        }
        phrases.pop_back();
        discard_phrase.pop_back();
      }
      else
      {
        // beginning of optional section
        result.push_back(QString());
        os.setString(&result.back());
        phrases.push_back(entry.content_);
        discard_phrase.push_back(QStringList());
      }
    }
    break;
    }
  }
  BUTTER_REQUIRE(phrases.empty(), "Incorrectly nested optional sections.");
}
return result.front();
