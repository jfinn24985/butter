class UmlArtifact
!!!273328.cpp!!!	~UmlArtifact()
this->update_description();
!!!273072.cpp!!!	document(in start_phrase : unistr, in end_phrase : unistr) : compound_document
if( ! this->doc_ )
{
  this->doc_.reset( new butter::compound_document );
  this->doc_->start_phrase( start_phrase );
  this->doc_->end_phrase( end_phrase );
  QByteArray tmp_( this->description() );
  if( ! tmp_.isEmpty() )
  {
    QTextIStream is_( &tmp_ );
    this->doc_->parse( is_ );
  }
}
return *(this->doc_);
!!!273200.cpp!!!	merge(inout art : UmlArtifact) : void
// check we have local doc or generate
if( nullptr == this->doc_.get() )
{
  BUTTER_REQUIRE( nullptr != art.doc_.get(), "Get document before merging." );
  this->document( art.doc_->start_phrase(), art.doc_->end_phrase() );
}
// check we have other doc or generate
if( nullptr == art.doc_.get() )
{
  art.document( this->doc_->start_phrase(), this->doc_->end_phrase() );
}
BUTTER_REQUIRE( nullptr != this->doc_.get() && nullptr != art.doc_.get(), "Unable to create compound documents from UmlArtifact object." );
// merge
this->doc_->merge( *art.doc_ );
!!!419504.cpp!!!	update_description() : void
// Only check if the document has been read.
if( nullptr != this->doc_.get() )
{
  // Compare to existing document
  QByteArray desc_;
  const QByteArray orig_desc_( this->description () );
  {
    QTextOStream os_( &desc_ );
    // Output using original date
    this->doc_->write( os_, true );
  }
  if( orig_desc_.size() != desc_.size()
     || std::strncmp(orig_desc_.data(),desc_.data(), orig_desc_.size()) )
  {
    QByteArray desc2_;
    {
      QTextOStream os_( &desc2_ );
      this->doc_->write( os_, false );
    }
    this->set_Description( desc2_ );
  }
}
!!!259760.cpp!!!	write_out(in full_path : enumerate_path, inout log : base_log) : void
if (document_stereotype() == this->stereotype())
{
  log.trace(log.info, "<p>Checking whether to write document : " + this->name() + "</p>");
  // If we have a compound document, check that the description 
  // has been updated
  this->update_description();
  // Only write non-empty docs.
  if (! this->description().isEmpty())
  {
    QByteArray document_prop_value_;
    this->propertyValue(output_label(), document_prop_value_);
    if (document_prop_value_.isEmpty() || (document_prop_value_ != nowrite_value()))
    {
      // Check for directories
      if(! full_path.exists() )
      {
        if(! full_path.mkpath() )
        {
          QString msg("<b>Fatal Error:</b> Unable to create path " + full_path.path());
          throw std::runtime_error(msg.toStdString());
        }
      }
      // Check file
      QString document_filepath_{ (full_path / this->name()).path() };
      if (! document_prop_value_.isEmpty())
      {
        document_filepath_ += "." + document_prop_value_;
      }
      bool result{ false };
      if(QFile::exists(document_filepath_))
      {
        QFile iofile(document_filepath_);
        if (! iofile.open(IO_ReadOnly))
        {
          QString msg("<b>Fatal Error:</b> Unable to open file for reading: " + document_filepath_ + ": reason " + iofile.errorString());
          throw std::runtime_error(msg.toStdString());
        }
        QByteArray contents_{ iofile.readAll() };
        result = (contents_.size() == this->description().size()
                  && 0 == strncmp(contents_.constData(), this->description().constData(), contents_.size()));
        iofile.close();
      }
      if (! result)
      {
        log.trace(log.warn, "<p>Writing changed document : " + document_filepath_ + "</p>");
        QFile iofile(document_filepath_);
        if (! iofile.open(IO_WriteOnly))
        {
          QString msg("<b>Fatal Error:</b> Unable to open file for writing: " + document_filepath_ + ": reason " + iofile.errorString());
          throw std::runtime_error(msg.toStdString());
        }
        iofile.writeBlock(this->description(), this->description().size());
        iofile.close();
      }
      else
      {
        log.trace(log.info, "<p>Skipping unchanged document : " + document_filepath_ + "</p>");
      }
    }
  }
}
