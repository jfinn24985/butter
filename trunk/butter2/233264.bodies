class system_generator
!!!388656.cpp!!!	create_system(inout log : base_log) : void
BUTTER_REQUIRE(nullptr != this->style_.get(), "Need to have a style object before calling create_system");
BUTTER_REQUIRE(nullptr != this->root_.get(), "Need to have a location set before calling create_system");
QString start_phrase{ this->style_->get_start_phrase() };
QString end_phrase{ this->style_->get_end_phrase() };
////////////////////////////////////////////////////
// Check for top-level system build-file document(s)
// - create from template if necessary.
location_state * root_state{ static_cast<location_state *>(this->root_->root()->value()) };
{
  build_style::map_type sysfiles = this->style_->get_special_files();
  for(build_style::map_type::iterator elem = sysfiles.begin(); elem != sysfiles.end(); ++elem)
  {
    QVector< UmlItem * > doc_list = root_state->find_uml_document( elem.key() );
    // If more than 1, rename all but first
    for( int i_ = 1; i_ < doc_list.count(); ++i_ )
    {
      doc_list[i_]->set_Name( ("OLD_" + QByteArray::number(i_) + doc_list[i_]->name() ) );
    }
    if( 0 == doc_list.size() )
    {
      QByteArray desc{ elem.value().utf8() };
      root_state->add_uml_document(elem.key(), log)->set_Description(desc);
    }
  }
}
// - pointer to the top level build file
UmlArtifact * root_build_file = nullptr;
{
  root_build_file = this->get_build_file( root_state, this->style_->get_root_file_name().utf8() );
  if( nullptr == root_build_file )
  {
    UmlItem::string_map projectbook;
    const QByteArray package_name_{ UmlPackage::getProject()->name() };
    UmlPackage::getProject()->in_scope(projectbook, false, log);
    projectbook["name"] = package_name_;
    projectbook["NAME"] = package_name_.toUpper();
    projectbook["root-dir"] = this->root_->base_path();
    root_build_file = root_state->add_uml_document(this->style_->get_root_file_name(), log);
    root_build_file->document(start_phrase, end_phrase).preamble().value = this->style_->make_element(preamble_root(), projectbook);
  }
}

//////////////
// Process the project, handling items as we go.
//
QStack< location * > location_stack_;
location_stack_.push_back(this->root_->root());

while( ! location_stack_.isEmpty() )
{
  location * top_ = location_stack_.pop();
  // Push children onto stack
  for( int ii_ = 0; ii_ < top_->children().count(); ++ii_ )
  {
    location_stack_.push( top_->children().at( ii_ ) );
  }

  location_state * state{ static_cast<location_state *>(top_->value()) };
  // Build file for the current location.
  UmlArtifact * build_file = nullptr;
  if( state == root_state )
  {
    build_file = root_build_file;
  }
  else
  {
    build_file = this->get_build_file( state, this->style_->get_build_file_name().utf8() );
    if( nullptr == build_file  )
    {
      build_file = root_state->add_uml_document(this->style_->get_build_file_name(), log);
      UmlItem::string_map packbook;
      for( int i_ = 0; i_ < state->packages().count(); ++i_ )
      {
        state->packages().at(i_)->in_scope(packbook, false, log);
      }
      build_file->document(start_phrase, end_phrase).preamble().value = this->style_->make_element(preamble(), packbook);
    }
  }
  // Get deployment views from current location's packages
  for( int i_ = 0; i_ < state->packages().count(); ++i_ )
  {
    UmlPackage * I_ = state->packages().at( i_ );
    const QByteArray package_name_{ I_->name() };
    {
      UmlItem::string_map packbook;
      I_->in_scope(packbook, false, log);
      packbook["package"] = package_name_;
      packbook["PACKAGE"] = package_name_.toUpper();
      build_file->document(start_phrase, end_phrase)["package-" + I_->name()].value = this->style_->make_element("package", packbook);
    }
    for( unsigned int j_ = 0; j_ < I_->children().count(); ++j_ )
    {
      UmlItem * J_ = I_->children().at( j_ );
      if( aDeploymentView == J_->kind() )
      {
        // Scan deployment views for targets.
        for( unsigned int k_ = 0; k_ < J_->children().count(); ++ k_ )
        {
          UmlItem * item_ = J_->children().at( k_ );
          if ( anArtifact == item_->kind() )           // UmlArtifacts.
          {
            UmlArtifact & art_item_ = dynamic_cast< UmlArtifact & >( *item_ );
            const QByteArray stereotype_label_( const_cast< UmlArtifact & >( art_item_ ).stereotype() );
            const QByteArray target_name_( const_cast< UmlArtifact &>(art_item_).name() );
            UmlItem::string_map targetbook;
            item_->in_scope( targetbook, true, log );
            targetbook["package"] = package_name_;
            targetbook["PACKAGE"] = package_name_.toUpper();
            targetbook["name"] = target_name_;
            targetbook["NAME"] = target_name_.toUpper();
            if( stereotype_label_.contains( UmlItem::executable_stereotype() )
                || stereotype_label_.contains( UmlItem::library_stereotype() ) )
            {
              UmlItem::string_map fullbook;
              item_->in_scope( fullbook, false, log );
              if( targetbook.end() != targetbook.find( UmlItem::project_label() ) )
              {
                //////////////////////////////////////////////////
                // Is an external target for project.
                this->generate_external_target(&art_item_, root_build_file, targetbook, log);
              }
              else
              {
                this->generate_target(&art_item_, build_file, targetbook, log);
              }
            }
          }
        }
        // end target
      }
      // end deployment
    }
    // end package
  }
  // End of current location
  if ( top_ != this->root_->root() )
  {
    // add the inter-file links to the root buildfile
    UmlItem::string_map locbook;
    locbook["name"] = top_->path();
    locbook["path"] = top_->full_path();
    root_build_file->document(start_phrase, end_phrase)[top_->path()].value += this->style_->make_element("descendent-link", locbook);
  }
}

!!!445744.cpp!!!	generate_target(inout target : UmlArtifact, inout build_file : UmlArtifact, inout targetbook : build_style::map_type, inout log : base_log) : void
//////////////
// Is a local target
QString start_phrase{ this->style_->get_start_phrase() };
QString end_phrase{ this->style_->get_end_phrase() };
const QByteArray target_name_( target->name() );
log.trace(base_log::debug, "Local target "+target_name_+" is library or executable");
const QByteArray stereotype_label_( target->stereotype() );
bool installable_ = true;

if( target->associatedArtifacts().isEmpty() )
{
  log.trace(base_log::warn, "No associated objects for target "+target_name_+", ignoring" );
  return;
}
// The target's type, set to exe then change if library etc
log.trace(base_log::debug, "- target assumed executable");
if ( stereotype_label_ == UmlItem::library_stereotype() )
{
  log.trace(base_log::debug, "- target found to be library");
  QString value_;
  UmlItem::string_map fullbook;
  target->in_scope( fullbook, true, log );
  auto itr = fullbook.find( UmlItem::lib_type_label() );
  if( fullbook.end() != itr && itr.value() == UmlItem::shared_value() )
  {
    log.trace(base_log::debug, "- library is shared type");
    targetbook[ UmlItem::install_label() ] = "$(LIBDIR)";
    if(targetbook.end() == targetbook.find(UmlItem::install_mode_label()))
    {
      targetbook[ UmlItem::install_mode_label() ] = "$(LIBIFLAGS)";
    }
  }
  else
  {
    log.trace(base_log::debug, "- library is static type");
    installable_ = false;
  }
}
else
{
  auto itr = targetbook.find( UmlItem::install_label() );
  if( itr != targetbook.end() )
  {
    installable_ = ( constants::no_install_value != itr.value() );
  }
  else
  {
    log.trace(base_log::debug, "- target type assumed to be executable");
    targetbook[ UmlItem::install_label() ] = "$(BINDIR)";
  }
  if(installable_ && targetbook.end() == targetbook.find(UmlItem::install_mode_label()))
  {
    targetbook[ UmlItem::install_mode_label() ] = "$(BINIFLAGS)";
  }
}
///////////////////
// Start the target entry.
QString entry;
{
  QTextOStream eos{ &entry };

  eos << this->style_->make_element("target-start", targetbook);

  auto append_if_present = [](QString const& label, UmlItem::string_map const& book1, UmlItem::string_map & book2)
  {
    auto itr = book1.find(label);
    if( itr != book1.end() )
    {
      QString value = book2[label];
      book2[label] = (value.isEmpty() ? itr.value() : value + " " + itr.value());
    }
  };

  ///////////////////////
  // PROCESS DEPENDENCIES
  ///////////////////////
  for( unsigned int i_ = 0; i_ < target->associatedArtifacts().size(); ++i_ )
  {
    UmlArtifact * const current_art_ = target->associatedArtifacts().at( i_ );
    const QByteArray stereotype_( current_art_->stereotype().data() );
    UmlItem::string_map currentbook;
    current_art_->in_scope( currentbook, false, log );
    if( stereotype_ == UmlItem::library_stereotype() )
    {
      // For associated libraries, need to pass include, flags and ldflags to target
      append_if_present(UmlItem::include_label(), currentbook, targetbook);
      append_if_present(UmlItem::ldflags_label(), currentbook, targetbook);
      append_if_present(UmlItem::flags_label(), currentbook, targetbook);
    }
    else if( stereotype_ == UmlItem::source_stereotype() )
    {
      // For source need to pass ldflags
      // If include or flags are set, then we need to create a separate object
      auto itr1 = currentbook.find( UmlItem::include_label() );
      auto itr2 = currentbook.find( UmlItem::flags_label() );
      const bool need_object { itr1 != currentbook.end() || itr2 != currentbook.end() };
      append_if_present(UmlItem::ldflags_label(), currentbook, targetbook);
      append_if_present(UmlItem::flags_label(), currentbook, targetbook);
      if( need_object )
      {
        currentbook["name"] = current_art_->name();
        currentbook["NAME"] = current_art_->name().toUpper();
        build_file->document(start_phrase, end_phrase)[current_art_->name()].value = this->style_->make_element("object", currentbook);
        targetbook["source"] += " " + current_art_->name() + "$(SUFOBJ)";
      }
      else
      {
        targetbook["source"] += " " + current_art_->name() + "$(SUFSRC)";
      }
    }
    else if( stereotype_ == UmlItem::document_stereotype() )
    {
      // For "document" is "other" type and need to pass ldflags and create object
      append_if_present(UmlItem::ldflags_label(), currentbook, targetbook);
      currentbook["name"] = current_art_->name();
      currentbook["NAME"] = current_art_->name().toUpper();
      build_file->document(start_phrase, end_phrase)[current_art_->name()].value = this->style_->make_element("object-other", currentbook);
      targetbook["source"] += " " + current_art_->name() + "$(SUFOBJ)";
    }
  }
  ////////////////////
  // End of dependencies, create target
  if( targetbook.end() != targetbook.find( UmlItem::other_label() ) 
    && stereotype_label_ == UmlItem::library_stereotype() )
  {
    log.trace(base_log::debug, "- library is other type");
    installable_ = false;
    eos << this->style_->make_element("target-other", targetbook);
  }
  else
  {
    eos << this->style_->make_element("target", targetbook);
  }
  if( installable_ )
  {
    log.trace(base_log::debug, "- adding install section");
    eos << this->style_->make_element("target-install", targetbook);
  }
  else
  {
    log.trace(base_log::debug, "- not installable");
  }
}
if(! entry.isEmpty())
{
  std::swap(build_file->document(start_phrase, end_phrase)[target_name_].value, entry);
}

!!!445872.cpp!!!	generate_external_target(in target : UmlArtifact, inout build_file : UmlArtifact, inout targetbook : build_style::map_type, inout log : base_log) : void
QString start_phrase{ this->style_->get_start_phrase() };
QString end_phrase{ this->style_->get_end_phrase() };
QString extern_project_name{ targetbook[ UmlItem::project_label() ] };
//////////////////////////////////////////////////
// Is an external target for project.
if( targetbook.end() != targetbook.find( UmlItem::buildfile_label() ) )
{
  // Ensure inclusion of external build file for external project
  build_file->document(start_phrase, end_phrase)[extern_project_name].value = this->style_->make_element("include-buildfile", targetbook);
}
else
{
  // If needed, add external library preamble
  if( build_file->document(start_phrase, end_phrase)[extern_project_name].value.isEmpty() )
  {
    build_file->document(start_phrase, end_phrase)[extern_project_name].value = this->style_->make_element("extern-preamble", targetbook);
  }
  build_file->document(start_phrase, end_phrase)[extern_project_name].value += this->style_->make_element("extern-library", targetbook);
}
!!!452400.cpp!!!	get_build_file(inout state : location_state, in file_name : string) : UmlArtifact
// - pointer to the top level build file
UmlArtifact * build_file = nullptr;
QString start_phrase{ this->style_->get_start_phrase() };
QString end_phrase{ this->style_->get_end_phrase() };
QVector< UmlItem * > doc_list = state->find_uml_document( file_name );
if( ! doc_list.isEmpty() )
{
  build_file = dynamic_cast< UmlArtifact * >( doc_list[0] );
  BUTTER_REQUIRE(nullptr != build_file, "Document UmlItem is not a UmlArtifact");
  // Merge if more than 1
  for( int i_ = 1; i_ < doc_list.count(); ++i_ )
  {
    build_file->document(start_phrase, end_phrase).merge(
      dynamic_cast< UmlArtifact * >( doc_list[i_] )->document(start_phrase, end_phrase) );
    doc_list[i_]->set_Name( ("OLD_" + doc_list[i_]->name() ) );
  }
  build_file->document(start_phrase, end_phrase).reset();
}
return build_file;
!!!337968.cpp!!!	parse_project(inout a_item : UmlItem, inout log : base_log) : void
///////////////////////
// Test preconditions
BUTTER_REQUIRE( aPackage == a_item.kind(), "Argument is not a UmlPackage item." );
// Use pointer cast to avoid bad_cast throw, even though
// we may throw in the next step..
UmlPackage * project = dynamic_cast < UmlPackage * >( &a_item );
BUTTER_REQUIRE( NULL != project && NULL == a_item.parent ()
  , "<p><b>Program error:</b> Item is not a package or is not the top-level package.</p>" );
UmlItem::string_map project_addrbook;
project->in_scope(project_addrbook, true, log);
/////////////////////
// Set logging level
{
  auto itr = project_addrbook.find( UmlItem::log_level_label() );
  if ( project_addrbook.end() != itr )
  {
    log.set_level( itr.value().toInt() );
  }
}
/////////////////////////
// Set output build style
{
  QByteArray style_, xml_filename_;
  if ( ! project->propertyValue( "butter " + UmlItem::style_label(), style_ ) )
  {
    log.trace( base_log::info, "Using default style" );
    style_ = default_style_value();
  }
  log.trace( base_log::info, "Style: " + style_ );
  if ( ! project->propertyValue( "butter " + UmlItem::style_path_label(), xml_filename_ ) )
  {
    xml_filename_ = default_style_path_value();
  }
  this->style_->read_style( style_, xml_filename_ );
  log.trace( base_log::info, "Build file name set to: " + this->style_->get_build_file_name() );
}
/////////////////////
// Initialisation
butter::enumerate_path root_dir_( CppSettings::rootDir () ); // Project root dir.
log.trace( base_log::warn, "<p><b>Please wait:</b> building target list for project <i>"
  + a_item.name() + "</i>.</p>" );
BUTTER_ALWAYS( ! root_dir_.path ().isEmpty (), "<p><b>Error</b>Project C++ root directory is not set, please set it in the C++ generation dialog.</p>" );
// Ensure root directory exists.
if ( root_dir_.isRelative() )
{
  QFileInfo f_( project->supportFile() );
  root_dir_.setPath( f_.dir().filePath( root_dir_.path () ) );
}
log.trace( base_log::debug, "<p>Relative C++ root path expanded to: ["
  + root_dir_.path () + "].</p>" );
if ( ! root_dir_.exists() )
{
  if ( ! root_dir_.mkpath() )
  {
    QString msg_( "<p><b>The project root directory <pre>[" );
    msg_.append( root_dir_.path () );
    msg_.append( "]</pre> does not exists and could not be created</b>, please ensure that the root directory is a usable location.</p>" );
    throw std::runtime_error( msg_.utf8().data() );
  }
}
//  Check and create any user-directed top-level directory->
{
  auto itr = project_addrbook.find( UmlItem::base_label() );
  if ( project_addrbook.end() != itr )
  {
    const enumerate_path base_path_( root_dir_ / itr.value() );
    // Ensure directory exists.
    if ( ! base_path_.exists() )
    {
      if ( ! base_path_.mkpath() )
      {
        QString msg_( "<p><b>The base directory <pre>[" );
        msg_.append( base_path_.path () );
        msg_.append( "]</pre> does not exists and could not be created</b>, please ensure that the user supplied base directory is a usable locations.</p>" );
        throw std::runtime_error( msg_.utf8 ().data () );
      }
    }
    //  Create the initial base location object->
    this->root_.reset( new location_set( base_path_.path() ) );
  }
  else
  {
    this->root_.reset( new location_set( root_dir_.path() ) );
  }
}

if ( DEBUG )
{
  if(! log.have_stream())
  {
    log.debug_log( ( root_dir_ / butter::enumerate_path( "butter.log" ) ).path() );
  }
  if( log.have_stream() )
  {
    log.stream() << "##\n## BEGIN LOG FOR " << constants::BUTTER_VERSION << "\n##\n";
  }
}
///////////////////////////////////
// Walk through the UmlItems.
QVector< UmlItem * > item_stack_; // in-order project descent stack
// Push items onto stack
item_stack_.push_back( &a_item );
while ( ! item_stack_.isEmpty () )
{
  UmlItem * const top_ = item_stack_.back();
  item_stack_.pop_back();
  // Cache location pointer used when adding UmlPackages->
  butter::location * cache_ = NULL;

  // Assign any packages to a location object
  if ( aPackage == top_->kind () )
  {
    UmlPackage * pack_item_ = dynamic_cast< UmlPackage * >( top_ );
    BUTTER_CHECK( nullptr != pack_item_, "<p>Item type and class type do not match.</p>" );
    // Create the simplest absolute path to package without reference to filesystem
    const enumerate_path pack_path_( pack_item_->cppSrcDir() );
    BUTTER_CHECK( ! pack_path_.path().isEmpty (), "<p><b>Programming error:</b> Directory path for a package was found empty</p>" );
    // Ensure directory exists.
    if ( ! pack_path_.exists() )
    {
      if ( ! pack_path_.mkpath() )
      {
        const QString msg_( "<p><b>A package directory <pre>[" + pack_path_.path () + "]</pre> does not exist and could not be created</b>, please ensure that all packages have usable locations. Running the code generator first may avoid this error.</p>" );
        throw std::runtime_error( msg_.utf8 ().data () );
      }
    }
    // Find/Create location, reparenting tree if necessary, and add package.
    if ( DEBUG )
    {
      log.stream() << "## Finding/creating location for Package [" << pack_item_->name()
        << "] at path [" << pack_path_.path() << "]\n";
    }
    cache_ = this->root_->insert( pack_path_.path() );
    location_state * state_{ static_cast< location_state* >(cache_->value()) };
    if(nullptr == state_)
    {
      std::unique_ptr< location_state >tmp( new location_state );
      cache_->value(tmp.get());
      state_ = tmp.release();
    }
    state_->add_package( *pack_item_ );
  }
  if ( DEBUG )
  {
    {
      unsigned int depth_( 0 );
      UmlItem * print_tmp_ = top_;
      for ( ; NULL != print_tmp_; ++depth_ )
      {
        print_tmp_ = print_tmp_->parent();
      }
      top_->debug_print( depth_, log.stream() );
    }
  }
  // Push any children onto the stack
  auto const & kids_ = top_->children();
  for ( unsigned int i_ = 0; i_ < kids_.size(); ++i_ )
  {
    BUTTER_CHECK( NULL != kids_.at ( i_ ), "<p><b>Program error</b> Nul objects were children of an UmlItem.</p>" );
    item_stack_.push_back( kids_.at( i_ ) );
  }
}
if ( DEBUG )
{
// Output debugging information.
  this->root_->serialize( log.stream() );
}
// Perform exit test(s)
{
  auto itr = project_addrbook.find( UmlItem::base_label() );
  if ( project_addrbook.end() != itr )
  {
    const enumerate_path base_path_( root_dir_ / itr.value() );
    if ( ! base_path_.equality( this->root_->base_path() ) )
    {
      log.trace( base_log::warn, "<p><b>Warning:</b> User set root directory is not the parent of all project directories and has been ignored.</p>" );
    }
  }
}
// HERE
// Check whether base location has an associated package and attempt to create
// one.
location_state * state_{ static_cast< location_state* >(this->root_->root()->value()) };
if(nullptr == state_)
{
  std::unique_ptr< location_state >tmp( new location_state );
  this->root_->root()->value(tmp.get());
  state_ = tmp.release();
}
if ( state_->empty() )
{
  QString new_name_( "Build" );
  bool top_package_is_writable_( a_item.isWritable () );
  QString msg_;
  QTextOStream mos_( &msg_ );
  mos_ << "<p><pre>[" << this->root_->base_path() << "]</pre> found as parent directory";
  if ( top_package_is_writable_ )
  {
    bool name_not_found_( true );
    for ( unsigned int i_ = 0; name_not_found_ && i_ < a_item.children().count (); ++i_ )
    {
      name_not_found_ = ( new_name_ != a_item.children().at ( i_ )->name().data ()
          || aPackage != a_item.children().at ( i_ )->kind() );
    }
    if ( ! name_not_found_ )
    {
      for ( unsigned int j_ = 1; j_ < 10; ++j_ )
      {
        QString cmpd_name_;
        cmpd_name_.setNum( j_ );
        cmpd_name_.prepend( new_name_ );
        name_not_found_ = true;
        for ( unsigned int i_ = 0; name_not_found_ && i_ < a_item.children().count (); ++i_ )
        {
          name_not_found_ = ( cmpd_name_ != a_item.children().at( i_ )->name ().data ()
              || aPackage != a_item.children().at( i_ )->kind() );
        }
        if ( name_not_found_ )
        {
          new_name_ = cmpd_name_;
          break;
        }
      }
    }
    if ( ! name_not_found_ )
    {
      mos_ << " but I can not create UML package for this location. Do one of:<p>\n";
      mos_ << "<ul><li>Create/modify a package with this directory.</li>\n";
      mos_ << "<li>Change existing directories to change parent directory.</li></ul>\n";
      throw std::runtime_error( msg_.utf8().data() );
    }
    else
    {
      mos_ << ". 'Ok' to create a package '" << new_name_ << "' with this directory ";
      mos_ << "or 'Cancel' and do one of:<p>\n";
      mos_ << "<ul><li>Create/modify a package with this directory.</li>\n";
      mos_ << "<li>Change existing directories to change parent directory.</li></ul>\n";
      if ( 1 == this->interaction_ or ( 0 == this->interaction_ and QMessageBox::Ok ==
#if QT_VERSION < 300L
        QMessageBox::warning
#else
        QMessageBox::question
#endif
        ( 0
          , "Butter: Parent directory is outside project."
          , msg_
          , QMessageBox::Ok
          , QMessageBox::Abort ) ) )
      {
        UmlPackage * build_ = UmlPackage::create( dynamic_cast< UmlPackage * >( &a_item ), new_name_ );
        butter::enumerate_path helper_( CppSettings::rootDir () );
        build_->set_CppSrcDir( helper_.create_relative( this->root_->base_path() ).utf8 () );
        static_cast< location_state * >(this->root_->root()->value())->add_package( *build_ );
      }
      else
      {
        throw std::runtime_error( "<p>Program aborted at user request.</p>" );
      }
    }
  }
  else
  {
    mos_ << " and project is not writable.<p>\n";
    throw std::runtime_error( msg_.utf8().data() );
  }
  if( DEBUG && this->root_ )
  {
    this->root_->serialize(log.stream());
  }
}

!!!453040.cpp!!!	write_documents(inout log : base_log) : void
butter::location_state::write_documents( *(this->root_), log );
