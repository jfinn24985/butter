class butter_application
!!!337968.cpp!!!	parse_project(inout a_item : UmlItem, inout log : base_log) : void
///////////////////////
// Test preconditions
BUTTER_REQUIRE( aPackage == a_item.kind(), "Argument is not a UmlPackage item." );
// Use pointer cast to avoid bad_cast throw, even though
// we may throw in the next step..
UmlPackage * project = dynamic_cast < UmlPackage * >( &a_item );
BUTTER_REQUIRE( NULL != project && NULL == a_item.parent ()
  , "<p><b>Program error:</b> Item is not a package or is not the top-level package.</p>" );
UmlItem::string_map project_addrbook;
project->in_scope(project_addrbook, true, log);
/////////////////////
// Set logging level
{
  auto itr = project_addrbook.find( UmlItem::log_level_label() );
  if ( project_addrbook.end() != itr )
  {
    log.set_level( itr.value().toInt() );
  }
}
/////////////////////
// Initialisation
butter::enumerate_path root_dir_( CppSettings::rootDir () ); // Project root dir.
log.trace( base_log::warn, "<p><b>Please wait:</b> building target list for project <i>"
  + a_item.name() + "</i>.</p>" );
BUTTER_ALWAYS( ! root_dir_.path ().isEmpty (), "<p><b>Error</b>Project C++ root directory is not set, please set it in the C++ generation dialog.</p>" );
// Ensure root directory exists.
if ( root_dir_.isRelative() )
{
  QFileInfo f_( project->supportFile() );
  root_dir_.setPath( f_.dir().filePath( root_dir_.path () ) );
}
log.trace( base_log::debug, "<p>Relative C++ root path expanded to: ["
  + root_dir_.path () + "].</p>" );
if ( ! root_dir_.exists() )
{
  if ( ! root_dir_.mkpath() )
  {
    QString msg_( "<p><b>The project root directory <pre>[" );
    msg_.append( root_dir_.path () );
    msg_.append( "]</pre> does not exists and could not be created</b>, please ensure that the root directory is a usable location.</p>" );
    throw std::runtime_error( msg_.utf8().data() );
  }
}
//  Check and create any user-directed top-level directory->
{
  auto itr = project_addrbook.find( UmlItem::base_label() );
  if ( project_addrbook.end() != itr )
  {
    const enumerate_path base_path_( root_dir_ / itr.value() );
    // Ensure directory exists.
    if ( ! base_path_.exists() )
    {
      if ( ! base_path_.mkpath() )
      {
        QString msg_( "<p><b>The base directory <pre>[" );
        msg_.append( base_path_.path () );
        msg_.append( "]</pre> does not exists and could not be created</b>, please ensure that the user supplied base directory is a usable locations.</p>" );
        throw std::runtime_error( msg_.utf8 ().data () );
      }
    }
    //  Create the initial base location object->
    this->root_.reset( new location_set( base_path_.path() ) );
  }
  else
  {
    this->root_.reset( new location_set( root_dir_.path() ) );
  }
}

if ( DEBUG )
{
  if(! log.have_stream())
  {
    log.debug_log( ( root_dir_ / butter::enumerate_path( "butter.log" ) ).path() );
  }
  if( log.have_stream() )
  {
    log.stream() << "##\n## BEGIN LOG FOR " << constants::BUTTER_VERSION << "\n##\n";
  }
}
///////////////////////////////////
// Walk through the UmlItems.
QVector< UmlItem * > item_stack_; // in-order project descent stack
// Push items onto stack
item_stack_.push_back( &a_item );
while ( ! item_stack_.isEmpty () )
{
  UmlItem * const top_ = item_stack_.back();
  item_stack_.pop_back();
  // Cache location pointer used when adding UmlPackages->
  butter::location * cache_ = NULL;

  // Assign any packages to a location object
  if ( aPackage == top_->kind () )
  {
    UmlPackage * pack_item_ = dynamic_cast< UmlPackage * >( top_ );
    BUTTER_CHECK( nullptr != pack_item_, "<p>Item type and class type do not match.</p>" );
    // Create the simplest absolute path to package without reference to filesystem
    const enumerate_path pack_path_( pack_item_->cppSrcDir() );
    BUTTER_CHECK( ! pack_path_.path().isEmpty (), "<p><b>Programming error:</b> Directory path for a package was found empty</p>" );
    // Ensure directory exists.
    if ( ! pack_path_.exists() )
    {
      if ( ! pack_path_.mkpath() )
      {
        const QString msg_( "<p><b>A package directory <pre>[" + pack_path_.path () + "]</pre> does not exist and could not be created</b>, please ensure that all packages have usable locations. Running the code generator first may avoid this error.</p>" );
        throw std::runtime_error( msg_.utf8 ().data () );
      }
    }
    // Find/Create location, reparenting tree if necessary, and add package.
    if ( DEBUG )
    {
      log.stream() << "## Finding/creating location for Package [" << pack_item_->name()
        << "] at path [" << pack_path_.path() << "]\n";
    }
    cache_ = this->root_->insert( pack_path_.path() );
    location_state * state_{ static_cast< location_state* >(cache_->value()) };
    if(nullptr == state_)
    {
      std::unique_ptr< location_state >tmp( new location_state );
      cache_->value(tmp.get());
      state_ = tmp.release();
    }
    state_->add_package( *pack_item_ );
  }
  if ( DEBUG )
  {
    {
      unsigned int depth_( 0 );
      UmlItem * print_tmp_ = top_;
      for ( ; NULL != print_tmp_; ++depth_ )
      {
        print_tmp_ = print_tmp_->parent();
      }
      top_->debug_print( depth_, log.stream() );
    }
  }
  // Push any children onto the stack
  auto const & kids_ = top_->children();
  for ( unsigned int i_ = 0; i_ < kids_.size(); ++i_ )
  {
    BUTTER_CHECK( NULL != kids_.at ( i_ ), "<p><b>Program error</b> Nul objects were children of an UmlItem.</p>" );
    item_stack_.push_back( kids_.at( i_ ) );
  }
}
if ( DEBUG )
{
// Output debugging information.
  this->root_->serialize( log.stream() );
}
// Perform exit test(s)
{
  auto itr = project_addrbook.find( UmlItem::base_label() );
  if ( project_addrbook.end() != itr )
  {
    const enumerate_path base_path_( root_dir_ / itr.value() );
    if ( ! base_path_.equality( this->root_->base_path() ) )
    {
      log.trace( base_log::warn, "<p><b>Warning:</b> User set root directory is not the parent of all project directories and has been ignored.</p>" );
    }
  }
}
// HERE
// Check whether base location has an associated package and attempt to create
// one.
location_state * state_{ static_cast< location_state* >(this->root_->root()->value()) };
if(nullptr == state_)
{
  std::unique_ptr< location_state >tmp( new location_state );
  this->root_->root()->value(tmp.get());
  state_ = tmp.release();
}
if ( state_->empty() )
{
  QString new_name_( "Build" );
  bool top_package_is_writable_( a_item.isWritable () );
  QString msg_;
  QTextOStream mos_( &msg_ );
  mos_ << "<p><pre>[" << this->root_->base_path() << "]</pre> found as parent directory";
  if ( top_package_is_writable_ )
  {
    bool name_not_found_( true );
    for ( unsigned int i_ = 0; name_not_found_ && i_ < a_item.children().count (); ++i_ )
    {
      name_not_found_ = ( new_name_ != a_item.children().at ( i_ )->name().data ()
          || aPackage != a_item.children().at ( i_ )->kind() );
    }
    if ( ! name_not_found_ )
    {
      for ( unsigned int j_ = 1; j_ < 10; ++j_ )
      {
        QString cmpd_name_;
        cmpd_name_.setNum( j_ );
        cmpd_name_.prepend( new_name_ );
        name_not_found_ = true;
        for ( unsigned int i_ = 0; name_not_found_ && i_ < a_item.children().count (); ++i_ )
        {
          name_not_found_ = ( cmpd_name_ != a_item.children().at( i_ )->name ().data ()
              || aPackage != a_item.children().at( i_ )->kind() );
        }
        if ( name_not_found_ )
        {
          new_name_ = cmpd_name_;
          break;
        }
      }
    }
    if ( ! name_not_found_ )
    {
      mos_ << " but I can not create UML package for this location. Do one of:<p>\n";
      mos_ << "<ul><li>Create/modify a package with this directory.</li>\n";
      mos_ << "<li>Change existing directories to change parent directory.</li></ul>\n";
      throw std::runtime_error( msg_.utf8().data() );
    }
    else
    {
      mos_ << ". 'Ok' to create a package '" << new_name_ << "' with this directory ";
      mos_ << "or 'Cancel' and do one of:<p>\n";
      mos_ << "<ul><li>Create/modify a package with this directory.</li>\n";
      mos_ << "<li>Change existing directories to change parent directory.</li></ul>\n";
      if ( 1 == this->interaction_ or ( 0 == this->interaction_ and QMessageBox::Ok ==
#if QT_VERSION < 300L
        QMessageBox::warning
#else
        QMessageBox::question
#endif
        ( 0
          , "Butter: Parent directory is outside project."
          , msg_
          , QMessageBox::Ok
          , QMessageBox::Abort ) ) )
      {
        UmlPackage * build_ = UmlPackage::create( dynamic_cast< UmlPackage * >( &a_item ), new_name_ );
        butter::enumerate_path helper_( CppSettings::rootDir () );
        build_->set_CppSrcDir( helper_.create_relative( this->root_->base_path() ).utf8 () );
        static_cast< location_state * >(this->root_->root()->value())->add_package( *build_ );
      }
      else
      {
        throw std::runtime_error( "<p>Program aborted at user request.</p>" );
      }
    }
  }
  else
  {
    mos_ << " and project is not writable.<p>\n";
    throw std::runtime_error( msg_.utf8().data() );
  }
}

!!!344624.cpp!!!	main() : int
int result = 0;
if(0 == this->port_)
{
  // No Port number so plugout not set up properly
  return -1;
}
class connector
{
  bool ok_;
public:
  connector(int port)
    : ok_{}
  {
    ok_ = UmlCom::connect( port );
  }
  ~connector()
  {
    if(ok_)
    {
      UmlCom::bye(0);
      UmlCom::close();
    }
  }
  bool connected() const
  {
    return ok_;
  }
};

{
  connector c{ this->port_ };
  if ( c.connected() )
  {
    try
    {
      UmlCom::trace( "<b>build system generator</b> " + butter::constants::BUTTER_VERSION + "<br>" );
      if ( DEBUG and 0 == interaction_ )
      {
        QString msg_;
        QTextOStream mos_( &msg_ );
#ifdef __unix__
        mos_ << "Hit Ok to continue. If you want to debug this application attach to process [pid="
             << applicationPid() << "] before continuing.";
#else
#ifdef _WIN32
        mos_ << "Hit Ok to continue. If you want to debug this application attach to process [Id="
             << GetCurrentProcessId() << "] before continuing.";
#else
        mos_ << "Hit Ok to continue. If you want to debug this application attach to butter process now.";
#endif
#endif
        QMessageBox msg_box_( butter::constants::BUTTER_VERSION, msg_, QMessageBox::Warning, QMessageBox::Ok | QMessageBox::Default, QMessageBox::NoButton, QMessageBox::NoButton );
        msg_box_.exec();
      }
      BUTTER_CHECK( nullptr != UmlPackage::getProject (), "Error: no project defined!<br>" );
      /////////////////////////////////////////
      // Parse the project into a location tree
      butter::log l;
      l.debug_log("butter.log");
      this->parse_project( *UmlPackage::getProject(), l );
      if(this->root_)
      {
        std::cerr << "Root package found.\n";
        this->root_->serialize(l.stream());
      }
      else
      {
        std::cerr << "No root package found.\n";
        l.stream() << "No root package found.\n";
      }
      /////////////////////////
      // Set output build style
      {
        QByteArray style_, xml_filename_;
        if ( ! UmlPackage::getProject()->propertyValue( UmlItem::style_label(), style_ ) )
        {
          style_ = default_style_value();
        }
        if ( ! UmlPackage::getProject()->propertyValue( UmlItem::style_path_label(), xml_filename_ ) )
        {
          xml_filename_ = default_style_path_value();
        }
        this->style_->read_style( style_, xml_filename_ );
      }

      // TODO BELOW
      // Generate the build-system files.
      //std::unique_ptr< butter::base_generator > writer_( butter::style::get_style().create_writer() );
      this->create_system( l );
      // Write the build-system files.
      location_state::write_documents( *(this->root_), l );
    }
    catch ( const std::exception & a_err )
    {
      UmlCom::trace( a_err.what() );
      std::cerr << a_err.what() << "\n";
      result = -1;
    }
    catch ( const char * a_what )
    {
      UmlCom::trace( a_what );
      std::cerr << a_what << "\n";
      result = -1;
    }
    catch ( ... )
    {
      UmlCom::trace( "Caught unknown exception." );
      std::cerr << "Caught unknown exception.\n";
      result = -1;
    }

    UmlCom::trace( "<b>build system generator</b> complete<br>" );
  }
}
return result;
!!!374960.cpp!!!	butter_application(in argc : int, in argv : char)
int start = 0;
int end = argc;
std::cerr << "Number of arguments : " << end << "\n";
if(0 != end && QByteArray(argv[0]).startsWith("butter"))
{
  start = 1;
}
for(int i = start; i != end; ++i)
{
  std::cerr << "arguments[" << i << "] : " << argv[i] << "\n";
  QByteArray arg{ argv[i] };
  if( arg == "-test:ok" )
  {
    this->interaction_ = 1;
  }
  else if ( arg == "-test:cancel" )
  {
    this->interaction_ = 2;
  }
  else
  {
    this->port_ = arg.toUInt();
  }
}
!!!388656.cpp!!!	create_system(inout log : base_log) : void
BUTTER_REQUIRE(nullptr != this->style_.get(), "Need to have a style object before calling create_system");
BUTTER_REQUIRE(nullptr != this->root_.get(), "Need to have a location set before calling create_system");
enum target_type
{
  unknown = 0,
  static_library = 1,
  shared_library = 2,
  executable = 3,
  other = 4,
};
QString start_phrase{ this->style_->get_start_phrase() };
QString end_phrase{ this->style_->get_end_phrase() };
////////////////////////////////////////////////////
// Check for top-level system build-file document(s)
// - create from template if necessary.
location_state * root_state{ static_cast<location_state *>(this->root_->root()->value()) };
{
  build_style::map_type sysfiles = this->style_->get_special_files();
  for(build_style::map_type::iterator elem = sysfiles.begin(); elem != sysfiles.end(); ++elem)
  {
    QVector< UmlItem * > doc_list = root_state->find_uml_document( elem.key() );
    // TODO if more than 1, what to do?
    BUTTER_REQUIRE( doc_list.size() <= 1, "Too many root documents found");
    if( 0 == doc_list.size() )
    {
      QByteArray desc{ elem.value().utf8() };
      root_state->add_uml_document(elem.key(), log)->set_Description(desc);
    }
  }
}
// - pointer to the top level build file
UmlArtifact * root_build_file = nullptr;
{
  QVector< UmlItem * > doc_list = root_state->find_uml_document( this->style_->get_root_file_name() );
  // TODO if more than 1, what to do?
  if( 0 == doc_list.size() )
  {
    root_build_file = root_state->add_uml_document(this->style_->get_root_file_name(), log);
  }
  else
  {
    root_build_file = dynamic_cast< UmlArtifact * >( doc_list[0] );
    BUTTER_REQUIRE(nullptr != root_build_file, "Document UmlItem is not a UmlArtifact");
  }
}


//////////////
// Process the project, handling items as we go.
//
QStack< location * > location_stack_;
location_stack_.push_back(this->root_->root());

while( ! location_stack_.isEmpty() )
{
  location * top_ = location_stack_.pop();
  // Push children onto stack
  for( int ii_ = 0; ii_ < top_->children().count(); ++ii_ )
  {
    location_stack_.push( top_->children().at( ii_ ) );
  }

  location_state * state{ static_cast<location_state *>(top_->value()) };
  // Build file for the current location.
  UmlArtifact * build_file = nullptr;
  if( state == root_state )
  {
    build_file = root_build_file;
  }
  else
  {
    QVector< UmlItem * > doc_list = state->find_uml_document( this->style_->get_build_file_name() );
    // TODO if more than 1, what to do?
    if( 0 == doc_list.size() )
    {
      build_file = root_state->add_uml_document(this->style_->get_build_file_name(), log);
    }
    else
    {
      build_file = dynamic_cast< UmlArtifact * >( doc_list[0] );
      BUTTER_REQUIRE(nullptr != build_file, "Document UmlItem is not a UmlArtifact");
    }
  }
  // Get deployment views from current location's packages
  for( int i_ = 0; i_ < state->packages().count(); ++i_ )
  {
    UmlPackage * I_ = state->packages().at( i_ );
    for( unsigned int j_ = 0; j_ < I_->children().count(); ++j_ )
    {
      UmlItem * J_ = I_->children().at( j_ );
      if( aDeploymentView == J_->kind() )
      {
        // Scan deployment views for targets.
        for( unsigned int k_ = 0; k_ < J_->children().count(); ++ k_ )
        {
          UmlItem * item_ = J_->children().at( k_ );
          if ( anArtifact == item_->kind() )           // UmlArtifacts.
          {
            const UmlArtifact & art_item_ = dynamic_cast < UmlArtifact & >( *item_ );
            const QString stereotype_label_( const_cast< UmlArtifact & >( art_item_ ).stereotype() );
            bool installable_( false );
            const QString target_name_( const_cast< UmlArtifact &>(art_item_).name() );
            UmlItem::string_map targetbook;
            item_->in_scope( targetbook, true, log );
            targetbook["name"] = target_name_;
            targetbook["NAME"] = target_name_.toUpper();
            target_type target_type_( executable ); // The target's type, set to exe then change if library etc
            if( stereotype_label_.contains( UmlItem::executable_stereotype(), false )
                || stereotype_label_.contains( UmlItem::library_stereotype(), false ) )
            {
              installable_ = true;
              UmlItem::string_map fullbook;
              item_->in_scope( fullbook, false, log );
              if( targetbook.end() != targetbook.find( UmlItem::project_label() ) )
              {
                QString extern_project_name{ targetbook[ UmlItem::project_label() ] };
                //////////////////////////////////////////////////
                // Is an external target for project.
                if( targetbook.end() != targetbook.find( UmlItem::buildfile_label() ) )
                {
                  // Ensure inclusion of external build file
                  if( root_build_file->document(start_phrase, end_phrase).has_target(extern_project_name) )
                  {
                    if( root_build_file->document(start_phrase, end_phrase).at(extern_project_name).value.isEmpty() )
                    {
                      root_build_file->document(start_phrase, end_phrase)[extern_project_name].value = this->style_->make_element("include-buildfile", targetbook);
                    }
                  }
                }
                else
                {
                  // Add section for an external library
                  if( root_build_file->document(start_phrase, end_phrase).has_target(extern_project_name) )
                  {
                    // If needed, add external library preamble
                    if( root_build_file->document(start_phrase, end_phrase).at(extern_project_name).value.isEmpty() )
                    {
                      root_build_file->document(start_phrase, end_phrase)[extern_project_name].value = this->style_->make_element("extern-preamble", targetbook);
                    }
                  }
                  root_build_file->document(start_phrase, end_phrase)[extern_project_name].value += this->style_->make_element("extern-library", targetbook);
                }
              }
              else
              {
                //////////////
                // Is a local target


                ///////////////////////
                // PROCESS DEPENDENCIES
                ///////////////////////
                std::map< QByteArray, UmlArtifact * > assoc_arts_;
                // Make map to get sorted list of artifacts
                for( unsigned int i_ = 0; i_ < const_cast<UmlArtifact &>( art_item_ ).associatedArtifacts().size(); ++i_ )
                {
                  UmlArtifact * current_art_ = const_cast<UmlArtifact &>( art_item_ ).associatedArtifacts().at( i_ );
                  assoc_arts_.insert( std::make_pair( current_art_->name(), current_art_ ) );
                }

                // Only process targets with associated entries.
                if( ! assoc_arts_.empty() )
                {
                  QString entry_;           // The target entry
                  {
                    if ( stereotype_label_.contains( UmlItem::library_stereotype(), false ) )
                    {
                      QString value_;
                      auto itr = fullbook.find( UmlItem::lib_type_label() );
                      if( fullbook.end() != itr && itr.value() == UmlItem::shared_value() )
                      {
                        target_type_ = shared_library;
                      }
                      else
                      {
                        target_type_ = static_library;
                      }
                      itr = targetbook.find( UmlItem::lib_type_label() );
                      if( targetbook.end() != itr && itr.value() == UmlItem::shared_value() )
                      {
                        target_type_ = shared_library;
                      }
                      else
                      {
                        target_type_ = static_library;
                      }
                      if( targetbook.end() != targetbook.find( UmlItem::other_label() ) )
                      {
                        target_type_ = other;
                      }
                    }
                    QTextOStream entry_os_( &entry_ );
                    ///////////////////
                    // Start the target entry.
                    build_file->document(start_phrase, end_phrase)[target_name_].value = this->style_->make_element("target-start", targetbook);
                    ///////////////////
                    // Process the associated (dependent) artifacts
                    for( std::map< QByteArray, UmlArtifact * >::iterator itr = assoc_arts_.begin(); itr != assoc_arts_.end(); ++itr )
                    {
                      UmlArtifact * const current_art_ = itr->second;
                      const QString stereotype_( current_art_->stereotype ().data () );
                      UmlItem::string_map currentbook;
                      current_art_->in_scope( currentbook, false, log );
                      if( stereotype_ == UmlItem::library_stereotype() )
                      {
                        // For associated libraries, need to pass include, flags and ldflags to target
                        auto itr = currentbook.find( UmlItem::include_label() );
                        if( itr != currentbook.end() )
                        {
                          targetbook[ UmlItem::include_label() ] += " " + itr.value();
                        }
                        itr = currentbook.find( UmlItem::ldflags_label() );
                        if( itr != currentbook.end() )
                        {
                          targetbook[ UmlItem::ldflags_label() ] += " " + itr.value();
                        }
                        itr = currentbook.find( UmlItem::flags_label() );
                        if( itr != currentbook.end() )
                        {
                          targetbook[ UmlItem::flags_label() ] += " " + itr.value();
                        }
                      }
                      else if( stereotype_ == UmlItem::source_stereotype() )
                      {
                        // For source need to pass ldflags
                        // If include or flags are set, then we need to create object
                        bool need_object{ false };
                        auto itr = currentbook.find( UmlItem::include_label() );
                        if( itr != currentbook.end() )
                        {
                          need_object = true;
                        }
                        itr = currentbook.find( UmlItem::ldflags_label() );
                        if( itr != currentbook.end() )
                        {
                          targetbook[ UmlItem::ldflags_label() ] += " " + itr.value();
                        }
                        itr = currentbook.find( UmlItem::flags_label() );
                        if( itr != currentbook.end() )
                        {
                          need_object = true;
                        }
                        if( need_object )
                        {
                          currentbook["name"] = current_art_->name();
                          currentbook["NAME"] = current_art_->name().toUpper();
                          build_file->document(start_phrase, end_phrase)[current_art_->name()].value = this->style_->make_element("object", currentbook);
                          targetbook["source"] += " " + current_art_->name() + ".$(SUFOBJ)";
                        }
                        else
                        {
                          targetbook["source"] += " " + current_art_->name() + ".$(SUFSRC)";
                        }
                      }
                      else if( stereotype_ == UmlItem::document_stereotype() )
                      {
                        // For "document" need to pass ldflags and create object
                        auto itr = currentbook.find( UmlItem::ldflags_label() );
                        if( itr != currentbook.end() )
                        {
                          targetbook[ UmlItem::ldflags_label() ] += " " + itr.value();
                        }
                        currentbook["name"] = current_art_->name();
                        currentbook["NAME"] = current_art_->name().toUpper();
                        build_file->document(start_phrase, end_phrase)[current_art_->name()].value = this->style_->make_element("object-other", currentbook);
                        targetbook["source"] += " " + current_art_->name() + ".$(SUFOBJ)";
                      }
                    }
                    ////////////////////
                    // End target
                    build_file->document(start_phrase, end_phrase)[target_name_].value += this->style_->make_element("target", targetbook);
                  }
                }
              }
            }
            //////////////
            // Handle installables
            if( installable_ || stereotype_label_.contains( UmlItem::document_stereotype(), false ) )
            {
              auto itr = targetbook.find( UmlItem::install_label() );
              if( itr == targetbook.end() )
              {
                switch( target_type_ )
                {
                case static_library:
                case other:
                default:
                  // static libraries and other types without an install property are not installed
                  installable_ = false;
                  break;
                case shared_library:
                  targetbook[ UmlItem::install_label() ] = "$(LIBDIR)";
                  break;
                case executable:
                  targetbook[ UmlItem::install_label() ] = "$(BINDIR)";
                  break;
                }
              }
              else
              {
                installable_ = ( constants::no_install_value != itr.value() );
              }
              if( installable_ )
              {
                build_file->document(start_phrase, end_phrase)[target_name_].value += this->style_->make_element("target-install", targetbook);
              }
            }
          }
        }
        // end target
      }
      // end deployment
    }
    // end package
  }
  // End of current location
  if ( top_ != this->root_->root() )
  {
    // add the inter-file link
    UmlItem::string_map locbook;
    locbook["name"] = top_->path();
    locbook["path"] = top_->full_path();
    root_build_file->document(start_phrase, end_phrase)[top_->path()].value += this->style_->make_element("descendent-link", locbook);
  }
}

