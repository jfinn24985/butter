class butter_application
!!!337968.cpp!!!	parse_project(inout a_item : UmlItem, inout log : base_log) : void
///////////////////////
// Test preconditions
BUTTER_REQUIRE( aPackage == a_item.kind(), "Argument is not a UmlPackage item." );
// Use pointer cast to avoid bad_cast throw, even though
// we may throw in the next step..
UmlPackage * project = dynamic_cast < UmlPackage * >( &a_item );
BUTTER_REQUIRE( NULL != project && NULL == a_item.parent ()
  , "<p><b>Program error:</b> Item is not a package or is not the top-level package.</p>" );
/////////////////////
// Set logging level
QByteArray level_;
if ( project->propertyValue( log_level_prop_name(), level_ ) )
{
  log.set_level( level_.toInt() );
}
/////////////////////
// Initialisation
butter::enumerate_path root_dir_( CppSettings::rootDir () ); // Project root dir.
log.trace( base_log::warn, "<p><b>Please wait:</b> building target list for project <i>"
  + a_item.name() + "</i>.</p>" );
BUTTER_ALWAYS( ! root_dir_.path ().isEmpty (), "<p><b>Error</b>Project C++ root directory is not set, please set it in the C++ generation dialog.</p>" );
// Ensure root directory exists.
if ( root_dir_.isRelative() )
{
  QFileInfo f_( project->supportFile() );
  root_dir_.setPath( f_.dir().filePath( root_dir_.path () ) );
}
log.trace( base_log::debug, "<p>Relative C++ root path expanded to: ["
  + root_dir_.path () + "].</p>" );
if ( ! root_dir_.exists() )
{
  if ( ! root_dir_.mkpath() )
  {
    QString msg_( "<p><b>The project root directory <pre>[" );
    msg_.append( root_dir_.path () );
    msg_.append( "]</pre> does not exists and could not be created</b>, please ensure that the root directory is a usable location.</p>" );
    throw std::runtime_error( msg_.utf8().data() );
  }
}
//  Check and create any user-directed top-level directory->
QByteArray user_base_path_;
a_item.propertyValue( base_prop_name(), user_base_path_ );
if ( ! user_base_path_.isEmpty () )
{
  const enumerate_path base_path_( root_dir_ / user_base_path_ );
  // Ensure directory exists.
  if ( ! base_path_.exists() )
  {
    if ( ! base_path_.mkpath() )
    {
      QString msg_( "<p><b>The base directory <pre>[" );
      msg_.append( base_path_.path () );
      msg_.append( "]</pre> does not exists and could not be created</b>, please ensure that the user supplied base directory is a usable locations.</p>" );
      throw std::runtime_error( msg_.utf8 ().data () );
    }
  }
  //  Create the initial base location object->
  this->root_.reset( new location_set( base_path_.path() ) );
}
else
{
  this->root_.reset( new location_set( root_dir_.path() ) );
}

if ( DEBUG )
{
  if(! log.have_stream())
  {
    log.debug_log( ( root_dir_ / butter::enumerate_path( "butter.log" ) ).path() );
  }
  if( log.have_stream() )
  {
    log.stream() << "##\n## BEGIN LOG FOR " << constants::BUTTER_VERSION << "\n##\n";
  }
}
///////////////////////////////////
// Walk through the UmlItems.
QVector< UmlItem * > item_stack_; // in-order project descent stack
// Push items onto stack
item_stack_.push_back( &a_item );
while ( ! item_stack_.isEmpty () )
{
  UmlItem * const top_ = item_stack_.back();
  item_stack_.pop_back();
  butter::location * cache_ = NULL; // Cache location pointer used when adding UmlPackages->
//X1X  // Check property names.
//X1X  if ( base_log::warn <= log::com.level () )
//X1X  {
//X1X    // The 'if' always succeeds in this version as warn is lowest level
//X1X    QDict< QCString > property_map_( top_->properties () );
//X1X    QDictIterator < QCString > current_prop_( property_map_ );
//X1X    if ( ! current_prop_.isEmpty () )
//X1X    {
//X1X      for ( ; current_prop_.current (); ++current_prop_ )
//X1X      {
//X1X        if ( current_prop_.currentKey ().contains( "butter" ) )
//X1X        {
//X1X          const QString current_key_( current_prop_.currentKey ().data () );
//X1X          if ( current_key_ != constants::butter_base_name
//X1X            && current_key_ != constants::butter_build_dir_name
//X1X            && current_key_ != constants::butter_buildfile_name
//X1X            && current_key_ != constants::butter_compiler_name
//X1X            && current_key_ != constants::butter_flags_name
//X1X            && current_key_ != constants::butter_install_name
//X1X            && current_key_ != constants::butter_ldflags_name
//X1X            && current_key_ != constants::butter_lib_type_name
//X1X            && current_key_ != constants::butter_log_name
//X1X            && current_key_ != constants::butter_other_name
//X1X            && current_key_ != constants::butter_include_name
//X1X            && current_key_ != constants::butter_project_name
//X1X            && current_key_ != constants::butter_style_name
//X1X            && current_key_ != constants::butter_version_name )
//X1X          {
//X1X            log.trace( base_log::warn, "<p><b>Warning:</b> Item \"" + QString ( top_->name ().data () ) + "\" has property name \"" + current_key_ + "\" which contains 'butter' but is not a known property name</p>" );
//X1X          }
//X1X        }
//X1X      }
//X1X    }
//X1X  }
  // Assign any packages to a location object
  if ( aPackage == top_->kind () )
  {
    UmlPackage * pack_item_ = dynamic_cast< UmlPackage * >( top_ );
    BUTTER_CHECK( nullptr != pack_item_, "<p>Item type and class type do not match.</p>" );
    // Create the simplest absolute path to package without reference to filesystem
    const enumerate_path pack_path_( pack_item_->cppSrcDir() );
    BUTTER_CHECK( ! pack_path_.path().isEmpty (), "<p><b>Programming error:</b> Directory path for a package was found empty</p>" );
    // Ensure directory exists.
    if ( ! pack_path_.exists() )
    {
      if ( ! pack_path_.mkpath() )
      {
        const QString msg_( "<p><b>A package directory <pre>[" + pack_path_.path () + "]</pre> does not exist and could not be created</b>, please ensure that all packages have usable locations. Running the code generator first may avoid this error.</p>" );
        throw std::runtime_error( msg_.utf8 ().data () );
      }
    }
    // Find/Create location, reparenting tree if necessary, and add package.
    if ( DEBUG )
    {
      log.stream() << "## Finding/creating location for Package [" << pack_item_->name()
        << "] at path [" << pack_path_.path() << "]\n";
    }
    cache_ = this->root_->insert( pack_path_.path() );
    location_state * state_{ static_cast< location_state* >(cache_->value()) };
    if(nullptr == state_)
    {
      std::unique_ptr< location_state >tmp( new location_state );
      cache_->value(tmp.get());
      state_ = tmp.release();
    }
    state_->add_package( *pack_item_ );
  }
  if ( DEBUG )
  {
    {
      unsigned int depth_( 0 );
      UmlItem * print_tmp_ = top_;
      for ( ; NULL != print_tmp_; ++depth_ )
      {
        print_tmp_ = print_tmp_->parent();
      }
      top_->debug_print( depth_, log.stream() );
    }
  }
  // Push any children onto the stack
  auto const & kids_ = top_->children();
  for ( unsigned int i_ = 0; i_ < kids_.size(); ++i_ )
  {
    BUTTER_CHECK( NULL != kids_.at ( i_ ), "<p><b>Program error</b> Nul objects were children of an UmlItem.</p>" );
    item_stack_.push_back( kids_.at( i_ ) );
  }
}
if ( DEBUG )
{
// Output debugging information.
  this->root_->serialize( log.stream() );
}
// Perform exit test(s)
if ( ! user_base_path_.isEmpty() )
{
  const enumerate_path base_path_( root_dir_ / user_base_path_ );
  if ( ! base_path_.equality( this->root_->base_path() ) )
  {
    log.trace( base_log::warn, "<p><b>Warning:</b> User set root directory is not the parent of all project directories and has been ignored.</p>" );
  }
}
// HERE
// Check whether base location has an associated package and attempt to create
// one.
location_state * state_{ static_cast< location_state* >(this->root_->root()->value()) };
if(nullptr == state_)
{
  std::unique_ptr< location_state >tmp( new location_state );
  this->root_->root()->value(tmp.get());
  state_ = tmp.release();
}
if ( state_->empty() )
{
  QString new_name_( "Build" );
  bool top_package_is_writable_( a_item.isWritable () );
  QString msg_;
  QTextOStream mos_( &msg_ );
  mos_ << "<p><pre>[" << this->root_->base_path() << "]</pre> found as parent directory";
  if ( top_package_is_writable_ )
  {
    bool name_not_found_( true );
    for ( unsigned int i_ = 0; name_not_found_ && i_ < a_item.children().count (); ++i_ )
    {
      name_not_found_ = ( new_name_ != a_item.children().at ( i_ )->name().data ()
          || aPackage != a_item.children().at ( i_ )->kind() );
    }
    if ( ! name_not_found_ )
    {
      for ( unsigned int j_ = 1; j_ < 10; ++j_ )
      {
        QString cmpd_name_;
        cmpd_name_.setNum( j_ );
        cmpd_name_.prepend( new_name_ );
        name_not_found_ = true;
        for ( unsigned int i_ = 0; name_not_found_ && i_ < a_item.children().count (); ++i_ )
        {
          name_not_found_ = ( cmpd_name_ != a_item.children().at( i_ )->name ().data ()
              || aPackage != a_item.children().at( i_ )->kind() );
        }
        if ( name_not_found_ )
        {
          new_name_ = cmpd_name_;
          break;
        }
      }
    }
    if ( ! name_not_found_ )
    {
      mos_ << " but I can not create UML package for this location. Do one of:<p>\n";
      mos_ << "<ul><li>Create/modify a package with this directory.</li>\n";
      mos_ << "<li>Change existing directories to change parent directory.</li></ul>\n";
      throw std::runtime_error( msg_.utf8().data() );
    }
    else
    {
      mos_ << ". 'Ok' to create a package '" << new_name_ << "' with this directory ";
      mos_ << "or 'Cancel' and do one of:<p>\n";
      mos_ << "<ul><li>Create/modify a package with this directory.</li>\n";
      mos_ << "<li>Change existing directories to change parent directory.</li></ul>\n";
      if ( 1 == this->interaction_ or ( 0 == this->interaction_ and QMessageBox::Ok ==
#if QT_VERSION < 300L
        QMessageBox::warning
#else
        QMessageBox::question
#endif
        ( 0
          , "Butter: Parent directory is outside project."
          , msg_
          , QMessageBox::Ok
          , QMessageBox::Abort ) ) )
      {
        UmlPackage * build_ = UmlPackage::create( dynamic_cast< UmlPackage * >( &a_item ), new_name_ );
        butter::enumerate_path helper_( CppSettings::rootDir () );
        build_->set_CppSrcDir( helper_.create_relative( this->root_->base_path() ).utf8 () );
        static_cast< location_state * >(this->root_->root()->value())->add_package( *build_ );
      }
      else
      {
        throw std::runtime_error( "<p>Program aborted at user request.</p>" );
      }
    }
  }
  else
  {
    mos_ << " and project is not writable.<p>\n";
    throw std::runtime_error( msg_.utf8().data() );
  }
}

!!!344624.cpp!!!	main() : int
int result = 0;
if(0 == this->port_)
{
  // No Port number so plugout not set up properly
  return -1;
}
class connector
{
  bool ok_;
public:
  connector(int port)
    : ok_{}
  {
    ok_ = UmlCom::connect( port );
  }
  ~connector()
  {
    if(ok_)
    {
      UmlCom::bye(0);
      UmlCom::close();
    }
  }
  bool connected() const
  {
    return ok_;
  }
};

{
  connector c{ this->port_ };
  if ( c.connected() )
  {
    try
    {
      UmlCom::trace( "<b>build system generator</b> " + butter::constants::BUTTER_VERSION + "<br>" );
      if ( DEBUG and 0 == interaction_ )
      {
        QString msg_;
        QTextOStream mos_( &msg_ );
#ifdef __unix__
        mos_ << "Hit Ok to continue. If you want to debug this application attach to process [pid="
             << applicationPid() << "] before continuing.";
#else
#ifdef _WIN32
        mos_ << "Hit Ok to continue. If you want to debug this application attach to process [Id="
             << GetCurrentProcessId() << "] before continuing.";
#else
        mos_ << "Hit Ok to continue. If you want to debug this application attach to butter process now.";
#endif
#endif
        QMessageBox msg_box_( butter::constants::BUTTER_VERSION, msg_, QMessageBox::Warning, QMessageBox::Ok | QMessageBox::Default, QMessageBox::NoButton, QMessageBox::NoButton );
        msg_box_.exec();
      }
      BUTTER_CHECK( nullptr != UmlPackage::getProject (), "Error: no project defined!<br>" );
      /////////////////////////////////////////
      // Parse the project into a location tree
      butter::log l;
      l.debug_log("butter.log");
      this->parse_project( *UmlPackage::getProject(), l );
      if(this->root_)
      {
        std::cerr << "Root package found.\n";
        this->root_->serialize(l.stream());
      }
      else
      {
        std::cerr << "No root package found.\n";
        l.stream() << "No root package found.\n";
      }
      /////////////////////////
      // Set output build style
      {
        QByteArray style_, xml_filename_;
        if ( ! UmlPackage::getProject()->propertyValue( style_prop_name(), style_ ) )
        {
          style_ = default_style_value();
        }
        if ( ! UmlPackage::getProject()->propertyValue( style_path_prop_name(), xml_filename_ ) )
        {
          xml_filename_ = default_style_path_value();
        }
        this->style_->read_style( style_, xml_filename_ );
      }

      // TODO BELOW
      // Generate the build-system files.
      //std::unique_ptr< butter::base_generator > writer_( butter::style::get_style().create_writer() );
      //writer_->create_system( *base_.get(), *UmlPackage::getProject() );
      // Write the build-system files.
      //butter::location::write_documents( *base_.get() );
    }
    catch ( const std::exception & a_err )
    {
      UmlCom::trace( a_err.what() );
      std::cerr << a_err.what() << "\n";
      result = -1;
    }
    catch ( const char * a_what )
    {
      UmlCom::trace( a_what );
      std::cerr << a_what << "\n";
      result = -1;
    }
    catch ( ... )
    {
      UmlCom::trace( "Caught unknown exception." );
      std::cerr << "Caught unknown exception.\n";
      result = -1;
    }

    UmlCom::trace( "<b>build system generator</b> complete<br>" );
  }
}
return result;
!!!374960.cpp!!!	butter_application(in argc : int, in argv : char)
int start = 0;
int end = argc;
std::cerr << "Number of arguments : " << end << "\n";
if(0 != end && QByteArray(argv[0]).startsWith("butter"))
{
  start = 1;
}
for(int i = start; i != end; ++i)
{
  std::cerr << "arguments[" << i << "] : " << argv[i] << "\n";
  QByteArray arg{ argv[i] };
  if( arg == "-test:ok" )
  {
    this->interaction_ = 1;
  }
  else if ( arg == "-test:cancel" )
  {
    this->interaction_ = 2;
  }
  else
  {
    this->port_ = arg.toUInt();
  }
}
