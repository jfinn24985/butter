class UmlItem
!!!129473.cpp!!!	in_scope(inout addrbook : UmlItem::string_map, in only_direct : bool, inout log : base_log) : void
// Process any data from properties.
QByteArray value_;
Q3Dict<QByteArray> prop_{ this->properties() };
if ( ! prop_.isEmpty() )
{
  Q3DictIterator<QByteArray> current_prop_{ prop_ };
  for ( ; current_prop_.current(); ++current_prop_ )
  {
    if ( current_prop_.currentKey().contains( property_label_prefix() ) )
    {
      const QStringList parts_{ current_prop_.currentKey().split(" ", QString::SkipEmptyParts) };
      if(parts_.size() > 1 && parts_[0] == property_label_prefix())
      {
        if ( parts_[1] != base_label()
             && parts_[1] != build_dir_label()
             && parts_[1] != buildfile_label()
             && parts_[1] != compiler_label()
             && parts_[1] != flags_label()
             && parts_[1] != install_label()
             && parts_[1] != ldflags_label()
             && parts_[1] != lib_type_label()
             && parts_[1] != log_level_label()
             && parts_[1] != other_label()
             && parts_[1] != include_label()
             && parts_[1] != project_label()
             && parts_[1] != style_label()
             && parts_[1] != version_label() )
        {
          log.trace( butter::base_log::warn, ("<p><b>Warning:</b> Item \"" + this->name() + "\" has property name \"" + current_prop_.currentKey() + "\" which contains 'butter' but is not a known property name</p>") );
        }
        else
        {
          auto itr = addrbook.find(parts_[1]);
          if( itr != addrbook.end() )
          {
            itr.value() += " " + *(current_prop_.current());
          }
          else
          {
            addrbook.insert( parts_[1], *(current_prop_.current()) );
          }
        }
      }
    }
  }
}
// For non-documents also check for any data in the description.
if( ! this->stereotype().contains(document_stereotype()))
{
  QByteArray desc_{ this->description() };
  if( ! desc_.isEmpty() )
  {
    QString section_;
    const QByteArray marker_phrase_{ "${" + section_prefix() + "}" };
    const int start_{ desc_.find(marker_phrase_) };
    if (-1 != start_)
    {
      // Found a_section start, search from here to end for next section
      int end_{ desc_.find(marker_phrase_, start_ + marker_phrase_.length()) };
      if (-1 != end_)
      {
        section_ = desc_.mid(start_ + marker_phrase_.length(), end_ - (start_ + marker_phrase_.length()));
      }
      else
      {
        section_ = desc_.mid(start_ + marker_phrase_.length());
      }
      if (! section_.isEmpty ())
      {
        QRegExp hdr_re_("^ *" + header_label() + " *= *");
        QRegExp link_re_("^ *" + link_label() + " *= *");
        QRegExp flag_re_("^ *" + flag_label() + " *= *");
        if (! section_.isEmpty())
        {
          QTextIStream section_is_(&section_);
          while (! section_is_.atEnd())
          {
            const QString line_(section_is_.readLine());
            int length_;
            if (-1 != (length_ = hdr_re_.indexIn(line_, 0)))
            {
              auto itr = addrbook.find(include_label());
              if( itr != addrbook.end() )
              {
                itr.value() += " " + line_.mid(length_);
              }
              else
              {
                addrbook.insert( include_label(), line_.mid(length_) );
              }
            }
            else if (-1 != (length_ = link_re_.indexIn(line_, 0)))
            {
              auto itr = addrbook.find(ldflags_label());
              if( itr != addrbook.end() )
              {
                itr.value() += " " + line_.mid(length_);
              }
              else
              {
                addrbook.insert( ldflags_label(), line_.mid(length_) );
              }
            }
            else if (-1 != (length_ = flag_re_.indexIn(line_, 0)))
            {
              auto itr = addrbook.find(flags_label());
              if( itr != addrbook.end() )
              {
                itr.value() += " " + line_.mid(length_);
              }
              else
              {
                addrbook.insert( flags_label(), line_.mid(length_) );
              }
            }
          }
        }
      }
    }
  }
}
if(! only_direct && nullptr != this->parent())
{
  this->parent()->in_scope(addrbook, only_direct, log);
}
!!!359856.cpp!!!	debug_print(in depth : int, inout os : stream) : void
if (DEBUG)
{
  static const char kind_as_string_[][22] = {
"relation"
, "attribute"
, "operation"
, "extra class member"
, "class"
, "use case"
, "component"
, "node"
, "artifact"
, "NC relation"
, "class diagram"
, "use case diagram"
, "sequence diagram"
, "collaboration diagram"
, "component diagram"
, "deployment diagram"
, "class view"
, "use case view"
, "component view"
, "deployment view"
, "package"
, "unknown"
};
  static const int kind_size_(22);
  static const QString title_lbl_("[TT] ");
  static const QString watch_lbl_("[**] ");
  QString indent_;
  indent_.fill (' ', depth);
  os << indent_ << title_lbl_ << "Base information\n";
  os << indent_ << watch_lbl_ << "name = \"" << name() << "\"\n";
  os << indent_ << watch_lbl_ << "depth = \"" << depth << "\"\n";
  os << indent_ << watch_lbl_ << "stereotype = \"" << const_cast< UmlItem* >(this)->stereotype() << "\"\n";

  int kind_(const_cast< UmlItem& >(*this).kind ());
  os << indent_ << watch_lbl_ << "kind = \"" << kind_as_string_[(kind_ < 0 || kind_size_ <= kind_) ? kind_size_ - 1 : kind_] << "\" [" << kind_ << "]\n";
  os << indent_ << watch_lbl_ << "description = \"" << const_cast< UmlItem* >(this)->description () << "\"\n";

  Q3Dict< QByteArray > properties_(properties());

  if (properties_.isEmpty())
  {
    os << indent_ << title_lbl_ << "No Properties\n";
  }
  else
  {
    Q3DictIterator< QByteArray > props_(properties_);
    os << indent_ << title_lbl_ << "Properties (# = " << props_.count () << ")\n";
    for (; props_.current (); ++props_)
    {
      os << indent_ << watch_lbl_ << "[" << props_.currentKey() << "] = \""
	 << *(props_.current()) << "\"\n";
    }
    os << indent_ << title_lbl_ << "End Properties\n";
  }
}
